{
  "_meta": {
    "description": "Detailed information for exercises in the Fundamentals of Programming 2 course.",
    "usage": "Provides detailed descriptions, starter code, hints, and potentially solutions for exercises referenced by ID in FoP2_Summary.json.",
    "version": "1.0.0", // Version of this exercise details file structure
    "summary_file_version": "1.1.0", // The version of FoP2_Summary.json these details correspond to
    "field_meanings": {
      "exercise_id": "The unique identifier for the exercise (key of the main object).",
      "id": "Repeated exercise ID for self-reference within the object.",
      "title": "Exercise title (repeated from summary for context).",
      "detailed_description": "In-depth explanation of the exercise task, potentially using Markdown.",
      "starter_code": "Optional string containing starter code snippets or structure.",
      "hints": "Optional array of strings providing hints to the student.",
      "solution": "Optional string containing the solution code or explanation.",
      "testing_info": "Optional string describing how to test the solution (e.g., required tests, sample I/O).",
      "required_files": "Optional array of strings listing specific data files or resources needed."
    }
  },
  // Entry for H5H9.1
  "H5H9.1": {
    "id": "H5H9.1",
    "title": "Testen",
    "detailed_description": "## Exercise: Testing Fundamentals\n\nYour task is to write comprehensive JUnit tests for the provided `Calculator` class.\n\n1.  Analyze the `Calculator` class methods (`add`, `subtract`, `multiply`, `divide`).\n2.  Identify edge cases and boundary conditions (e.g., division by zero, large numbers, zero values).\n3.  Create a JUnit test class named `CalculatorTest`.\n4.  Write test methods covering:\n    * Basic valid inputs for each operation.\n    * Boundary values.\n    * Expected exceptions (e.g., for division by zero using `assertThrows`).\n5.  Use the IntelliJ debugger to step through one of your test cases and observe the execution flow within the `Calculator` class.",
    "starter_code": "```java\n// Calculator.java (Provided - Assume this class exists)\n/*\npublic class Calculator {\n    public int add(int a, int b) { ... }\n    public int subtract(int a, int b) { ... }\n    public int multiply(int a, int b) { ... }\n    public double divide(int a, int b) { ... }\n}\n*/\n\n// CalculatorTest.java (To be implemented by student)\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass CalculatorTest {\n    \n    // TODO: Add test methods here\n    // Example signature:\n    // @Test\n    // void testAddition() {\n    //     // ... implementation ...\n    // }\n    \n    // @Test\n    // void testDivisionByZero() {\n    //     // ... implementation using assertThrows ...\n    // }\n}\n```",
    "hints": [
      "Remember to import necessary JUnit classes (`Test`, `Assertions`).",
      "Think about equivalence partitioning for test case selection.",
      "Use `assertEquals` for checking return values and `assertThrows` for exceptions."
    ],
    "solution": "```java\n// Example Solution Snippet for divide by zero test\n@Test\nvoid testDivideByZero() {\n    Calculator calc = new Calculator();\n    assertThrows(IllegalArgumentException.class, () -> {\n        calc.divide(5, 0);\n    });\n}\n```",
    "testing_info": "Ensure all tests pass when run using the JUnit runner in IntelliJ. Aim for good code coverage.",
    "required_files": ["Calculator.java"]
  },
  // Entry for H5H9.2
   "H5H9.2": {
    "id": "H5H9.2",
    "title": "BreukenMetJUnitTest",
    "detailed_description": "## Oefening: JUnit Omgeving Opzetten voor Breuken\n\nDeze oefening focust op het correct configureren van de ontwikkelomgeving (IntelliJ) voor het gebruik van JUnit 5.\n\n**Situatie:**\nJe krijgt een startproject (\"Blended Learning testen - BreukMetTest\") met daarin een klasse `Breuk.java` en een testklasse `BreukTest.java`. De testklasse `BreukTest.java` zal initieel niet compileren omdat de JUnit 5 library nog niet aan het project is toegevoegd.\n\n**Opdracht:**\n\n1.  Open het startproject \"Blended Learning testen - BreukMetTest\" in IntelliJ.\n2.  Navigeer naar de test-folder en open `BreukTest.java`.\n3.  Observeer de compileerfouten bij de `import` statements voor JUnit (`org.junit.jupiter...`).\n4.  Gebruik de functionaliteit van IntelliJ om de JUnit 5 library automatisch toe te voegen aan de classpath van het project. Volg de stappen zoals aangegeven in het PDF-document (rode lampje / Alt+Enter -> \"Add 'JUnit 5.x' to classpath\" -> Bevestig download).\n5.  Controleer dat de klasse `BreukTest.java` nu correct compileert zonder fouten.",
    "starter_code": "```java\n// BreukTest.java (uit startproject, compileert initieel niet)\npackage be.vives.ti;\n\n// Deze imports geven initieel een foutmelding:\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class BreukTest {\n    private Breuk b1; // 3/4\n    private Breuk b2; // 1/2\n\n    @BeforeEach\n    public void setup() throws Exception {\n        b1 = new Breuk(3, 4);\n        b2 = new Breuk(1, 2);\n    }\n\n    @Test\n    public void testConstructor() {\n        // Bestaande testcode...\n    }\n\n    // Andere bestaande testmethodes...\n}\n\n// Breuk.java (uit startproject - structuur niet gespecificeerd in PDF)\n/*\npackage be.vives.ti;\npublic class Breuk {\n    // Attributen teller, noemer\n    // Constructor(teller, noemer)\n    // Methoden zoals plus, min, maal, deel, toString, ...\n}\n*/\n```",
    "hints": [
      "Zoek de rode onderlijning bij de `import org.junit.jupiter...` lijnen.",
      "Plaats je cursor op de fout en gebruik de sneltoets (vaak Alt+Enter) of klik op het rode lampje om de suggesties te zien.",
      "Kies de optie \"Add 'JUnit 5.x' to classpath\".",
      "Bevestig het downloaden van de library via Maven in het dialoogvenster dat verschijnt."
    ],
    "solution": null, // De 'oplossing' is het correct uitvoeren van de IDE stappen.
    "testing_info": "Het belangrijkste testcriterium is dat de klasse `BreukTest.java` compileert zonder fouten nadat de JUnit 5 library is toegevoegd. Optioneel kan je de testen in `BreukTest` uitvoeren om te zien of ze slagen (dit test de `Breuk` klasse zelf, wat niet het hoofddoel van deze specifieke setup-oefening is).",
    "required_files": ["Breuk.java", "BreukTest.java", "(Startproject 'Blended Learning testen - BreukMetTest')"]
  },
  // Entry for H6.1
  "H6.1": {
    "id": "H6.1",
    "title": "LageEmissieZone",
    "detailed_description": "## Oefening: Lage-emissiezone Controle\n\nHet doel is om een systeem te bouwen dat controleert of een voertuig een lage-emissiezone (LEZ) binnen mag op basis van de euronorm en brandstof, specifiek volgens de regels van Antwerpen (periode 01/01/2020 - 31/12/2024).\n\n**Context:**\nEen LEZ is een gebied waar vervuilende voertuigen beperkt worden. Toegang hangt af van de euronorm (1-6) en brandstof (Diesel, Benzine, Elektrisch). Elektrische voertuigen zijn altijd toegelaten.\n\n**Antwerpen LEZ Regels (01/01/2020 - 31/12/2024):**\n* **Diesel:**\n    * Euro 6/VI, 5/V: Toegang\n    * Euro 4/IV: Toegang na betaling\n    * Euro 3/III, 2/II, 1/I, Voor Euro: Toegang met LEZ-dagpas\n* **Benzine, Aardgas, LPG:**\n    * Euro 6/VI, 5/V, 4/IV, 3/III, 2/II: Toegang\n    * Euro 1/I, Voor Euro: Toegang met LEZ-dagpas\n* **Elektrisch:** Altijd Toegang\n\n**Opdracht:**\n\n1.  **Maak klasse `Auto`:**\n    * Attributen: `nummerplaat` (String), `merk` (String), `kleur` (String), `euronorm` (int 1-6), `brandstof` (String: \"Diesel\", \"Benzine\", of \"Elektrisch\").\n    * Objecten van deze klasse moeten onveranderlijk (immutable) zijn na creatie.\n    * Voorzie een constructor en getters.\n\n2.  **Maak klasse `LezChecker`:**\n    * Deze klasse beheert een lijst van gekende auto's, opzoekbaar via nummerplaat.\n    * Zorg voor een efficiënte manier om auto's op te zoeken (er zijn ~6 miljoen auto's in België).\n    * Elke nummerplaat mag slechts één keer voorkomen.\n    * Implementeer de volgende methodes:\n        * `void inschrijvenAuto(Auto auto)`: Voegt een auto toe aan de lijst.\n        * `void uitschrijvenAuto(String nummerplaat)`: Verwijdert een auto op basis van nummerplaat.\n        * `String controleerLezAntwerpen(String nummerplaat)`: Zoekt de auto op via nummerplaat. Bepaalt op basis van brandstof en euronorm de toegang volgens de Antwerpse LEZ-regels. Retourneert één van de volgende Strings: \"Toegang\", \"Toegang met LEZ-dagpas\", \"Toegang na betaling\", of \"Nummerplaat onbekend\".\n\n3.  **Maak klasse `Hoofdklasse`:**\n    * Bevat alleen een `main` methode voor testen.\n    * In `main`:\n        * Maak ~7 `Auto` objecten aan met verschillende euronormen/brandstoftypes.\n        * Registreer deze auto's via `LezChecker.inschrijvenAuto`.\n        * Controleer voor elke geregistreerde auto de toegang via `LezChecker.controleerLezAntwerpen` en druk het resultaat af.\n        * Schrijf één auto uit via `LezChecker.uitschrijvenAuto`.\n        * Controleer de toegang voor de uitgeschreven auto opnieuw en druk het resultaat af.",
    "starter_code": "```java\nimport java.util.HashMap;\nimport java.util.Map;\n\n// Klasse Auto (Immutable)\npublic class Auto {\n    private final String nummerplaat;\n    private final String merk;\n    private final String kleur;\n    private final int euronorm;\n    private final String brandstof; // \"Diesel\", \"Benzine\", \"Elektrisch\"\n\n    public Auto(String nummerplaat, String merk, String kleur, int euronorm, String brandstof) {\n        // TODO: Initialiseer attributen\n    }\n\n    // TODO: Getters voor alle attributen...\n    public String getNummerplaat() { /*...*/ return null; }\n    public String getMerk() { /*...*/ return null; }\n    public String getKleur() { /*...*/ return null; }\n    public int getEuronorm() { /*...*/ return 0; }\n    public String getBrandstof() { /*...*/ return null; }\n}\n\n// Klasse LezChecker\npublic class LezChecker {\n    // Hint: Use a Map to store cars, with number plate as the key\n    private Map<String, Auto> geregistreerdeAutos = new HashMap<>();\n\n    public LezChecker() { }\n\n    public void inschrijvenAuto(Auto auto) {\n        // TODO: Implementatie (voeg toe aan map, check uniekheid)\n    }\n\n    public void uitschrijvenAuto(String nummerplaat) {\n        // TODO: Implementatie (verwijder uit map)\n    }\n\n    public String controleerLezAntwerpen(String nummerplaat) {\n        // TODO: Implementatie (zoek op, check regels, retourneer string)\n        return \"Nummerplaat onbekend\"; // Placeholder\n    }\n}\n\n// Klasse Hoofdklasse\npublic class Hoofdklasse {\n    public static void main(String[] args) {\n        // TODO: Implementeer test scenario\n        LezChecker checker = new LezChecker();\n        // Maak auto's, schrijf in, controleer, schrijf uit, controleer opnieuw...\n    }\n}\n```",
    "hints": [
      "Gebruik een `java.util.HashMap<String, Auto>` in `LezChecker` om auto's efficiënt op te zoeken via hun nummerplaat (key).",
      "Vergeet niet het geval af te handelen waarbij de nummerplaat niet gevonden wordt in `controleerLezAntwerpen`.",
      "Implementeer de toegangslogica voor de LEZ zorgvuldig, met aandacht voor de verschillende brandstoftypes en euronormen.",
      "Elektrische auto's hebben altijd toegang, ongeacht de euronorm."
    ],
    "solution": null,
    "testing_info": "De `Hoofdklasse` dient als test. Zorg ervoor dat je auto's aanmaakt die verschillende scenario's testen (Diesel/Benzine/Elektrisch, verschillende euronormen die leiden tot verschillende toegangsniveaus). Verifieer dat de output van `controleerLezAntwerpen` overeenkomt met de verwachte toegangsniveaus en dat een uitgeschreven auto correct als \"Nummerplaat onbekend\" wordt gerapporteerd.",
    "required_files": []
  },
  // Entry for H6.2
  "H6.2": {
    "id": "H6.2",
    "title": "Bibliotheek",
    "detailed_description": "## Oefening: Bibliotheek Simulatie met HashMaps/HashSets\n\nDeze oefening is een aangepaste versie van een eerdere bibliotheek-oefening, nu met focus op het gebruik van `HashMap` en `HashSet`.\n\n**Doel:** Simuleer een bibliotheek waar leden boeken kunnen ontlenen.\n\n**Klassen:**\n\n1.  **`Lid`:**\n    * Attributen: `id` (String, uniek), `naam` (String), `adres` (String), `gemeente` (String).\n    * `adres` en `gemeente` moeten wijzigbaar zijn.\n    * Constructor met 4 argumenten.\n    * `toString()` methode.\n    * `equals()` en `hashCode()` methodes (gegenereerd door IntelliJ, gebaseerd *enkel* op `id`).\n\n2.  **`Boek`:**\n    * Attributen: `titel` (String), `auteur` (String), `isbn` (String), `id` (int, uniek per *exemplaar*), `status` (boolean: `true`=aanwezig, `false`=uitgeleend).\n    * Enkel `status` mag wijzigbaar zijn na creatie.\n    * Constructor met 4 argumenten.\n    * `toString()` methode.\n\n3.  **~~`Ontlening`~~:** Deze klasse wordt **verwijderd**. We gebruiken een `HashMap` om de koppeling tussen een uitgeleend boek en een lid te bewaren.\n\n4.  **`Balie`:**\n    * Beheert alle boeken, leden en ontleningen.\n    * Gebruik geschikte containers:\n        * Leden: Uniek, zelden opzoeken. (`HashSet<Lid>` aanbevolen).\n        * Boeken: Uniek per exemplaar (`id`), vaak opzoeken op `id`. (`HashMap<Integer, Boek>` aanbevolen).\n        * Ontleningen: Koppeling tussen uitgeleend `Boek` (via `id`) en `Lid` (via `id`). (`HashMap<Integer, String>` (BoekID -> LidID) aanbevolen).\n    * Constructor met 0 argumenten.\n    * Methodes:\n        * `void toevoegenBoek(Boek boek)`: Voegt boek toe aan de boekencollectie.\n        * `void toevoegenLid(Lid lid)`: Voegt lid toe aan de ledencollectie.\n        * `void ontleen(int boekId, Lid lid)`: Registreert een ontlening. Koppelt `boekId` aan `lid.getId()`. Past de `status` van het `Boek` aan. Geeft foutmelding indien boek al uitgeleend is.\n        * `void brengTerug(int boekId)`: Maakt ontlening ongedaan. Verwijdert de koppeling en past de `status` van het `Boek` aan.\n        * `void printOverzichtGeleendeBoeken()`: Toont alle boeken die momenteel uitgeleend zijn.\n        * `void printOverzichtAanwezigeBoeken()`: Toont alle boeken die momenteel aanwezig zijn.\n        * `void printOntleendeBoekenVanPersoon(String lidNaam)`: Toont alle boeken die door het lid met de opgegeven naam zijn ontleend (Tip: gebruik `entrySet()` op de ontleningen map).\n\n5.  **`Hoofdklasse`:**\n    * Bevat `main` methode voor testen.\n    * Maak ~10 boeken en ~8 leden aan.\n    * Maak `Balie` object aan, voeg boeken en leden toe.\n    * Voer enkele ontleningen uit.\n    * Druk overzichten af (geleend, aanwezig).\n    * Breng enkele boeken terug.\n    * Druk opnieuw overzichten af.\n    * Druk de geleende boeken van een specifiek lid af.",
    "starter_code": "```java\nimport java.util.HashSet;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\n\n// Klasse Lid\npublic class Lid {\n    private final String id;\n    private String naam;\n    private String adres;\n    private String gemeente;\n\n    public Lid(String id, String naam, String adres, String gemeente) {\n       // TODO: Initialiseer attributen\n    }\n\n    // TODO: Getters (ook voor id en naam)\n    public String getId() { /*...*/ return null; }\n    public String getNaam() { /*...*/ return null; }\n    public String getAdres() { /*...*/ return null; }\n    public String getGemeente() { /*...*/ return null; }\n\n    // TODO: Setters voor adres en gemeente\n    public void setAdres(String adres) { /*...*/ }\n    public void setGemeente(String gemeente) { /*...*/ }\n\n    @Override\n    public String toString() { /* TODO: Implementatie */ return \"\"; }\n\n    @Override\n    public boolean equals(Object o) {\n        // TODO: Genereer via IntelliJ (enkel op id)\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        // TODO: Genereer via IntelliJ (enkel op id)\n        return 0;\n    }\n}\n\n// Klasse Boek\npublic class Boek {\n    private final String titel;\n    private final String auteur;\n    private final String isbn;\n    private final int id; // Uniek per exemplaar\n    private boolean status; // true = aanwezig, false = uitgeleend\n\n    public Boek(String titel, String auteur, String isbn, int id) {\n        // TODO: Initialiseer attributen (status = true)\n    }\n\n    // TODO: Getters\n    public int getId() { /*...*/ return 0; }\n    public boolean isAanwezig() { /*...*/ return false; }\n    public String getTitel() { /*...*/ return null; }\n    // ... andere getters ...\n\n    // TODO: Setter voor status\n    public void setStatus(boolean status) { /*...*/ }\n\n    @Override\n    public String toString() { /* TODO: Implementatie */ return \"\"; }\n}\n\n// Klasse Balie\npublic class Balie {\n    private Set<Lid> leden = new HashSet<>();\n    private Map<Integer, Boek> boeken = new HashMap<>(); // Key = Boek ID\n    private Map<Integer, String> ontleningen = new HashMap<>(); // Key = Boek ID, Value = Lid ID\n\n    public Balie() {}\n\n    public void toevoegenBoek(Boek boek) { /* TODO: Implementatie */ }\n    public void toevoegenLid(Lid lid) { /* TODO: Implementatie */ }\n    public void ontleen(int boekId, Lid lid) { /* TODO: Implementatie */ }\n    public void brengTerug(int boekId) { /* TODO: Implementatie */ }\n    public void printOverzichtGeleendeBoeken() { /* TODO: Implementatie */ }\n    public void printOverzichtAanwezigeBoeken() { /* TODO: Implementatie */ }\n    public void printOntleendeBoekenVanPersoon(String lidNaam) { /* TODO: Implementatie */ }\n}\n\n// Klasse Hoofdklasse\npublic class Hoofdklasse {\n    public static void main(String[] args) {\n        // TODO: Implementeer test scenario\n    }\n}\n```",
    "hints": [
      "Gebruik `HashSet<Lid>` voor de ledenverzameling.",
      "Gebruik `HashMap<Integer, Boek>` voor de boekenverzameling, met de unieke `id` van het boek als sleutel.",
      "Gebruik `HashMap<Integer, String>` voor de ontleningen, waarbij de sleutel de `id` van het boek is en de waarde de `id` van het lid.",
      "Vergeet niet de `status` van een `Boek` aan te passen bij `ontleen` en `brengTerug`.",
      "Controleer of een boek al uitgeleend is voordat je het opnieuw probeert uit te lenen.",
      "Voor `printOntleendeBoekenVanPersoon`, itereer over `ontleningen.entrySet()` en zoek het bijhorende `Boek` en `Lid` object op om de naam te vergelijken."
    ],
    "solution": null,
    "testing_info": "Test grondig in `Hoofdklasse.main`. Maak voldoende objecten aan, voer ontleningen uit, breng boeken terug, en controleer de output van de print-methodes. Test ook het uitlenen van een reeds uitgeleend boek.",
    "required_files": []
  },
  // Entry for H6.3
  "H6.3": {
    "id": "H6.3",
    "title": "Vertaler",
    "detailed_description": "## Oefening: Woordenboek en Vertaler\n\nMaak een eenvoudig vertaalsysteem van Nederlands naar Engels.\n\n**Klassen:**\n\n1.  **`Woordenboek`:**\n    * Bevat een `HashMap<String, ArrayList<String>> woorden`. De sleutel is het Nederlandse woord, de waarde is een lijst van Engelse vertalingen.\n    * Bevat een `java.util.Random randomGenerator` veld.\n    * Constructor: Initialiseert de `HashMap` en `Random`.\n    * Methode `void voegVertalingToe(String nederlandsWoord, String engelseVertaling)`:\n        * Voegt de vertaling toe. Als het Nederlandse woord al bestaat, voeg de Engelse vertaling toe aan de bestaande lijst. Als het woord nieuw is, maak een nieuwe lijst aan met de vertaling en voeg het woord en de lijst toe aan de map.\n    * Methode `String geefWillekeurigeVertaling(String nederlandsWoord)`:\n        * Zoekt het Nederlandse woord op in de map.\n        * Indien gevonden en er zijn vertalingen, kies een willekeurige vertaling uit de lijst m.b.v. `randomGenerator` en retourneer deze.\n        * Indien niet gevonden of geen vertalingen, retourneer bijvoorbeeld het originele woord of een indicatie zoals \"[onbekend]\".\n\n2.  **`Vertaler`:**\n    * Heeft een `Woordenboek` object als attribuut.\n    * Constructor: Accepteert een `Woordenboek` object.\n    * Methode `String vertaalZin(String zin)`:\n        * Splits de input `zin` in woorden (bv. op spaties via `zin.split(\" \")`).\n        * Vraag voor elk woord de willekeurige vertaling op bij het `Woordenboek` object.\n        * Voeg de vertaalde woorden samen tot een nieuwe zin (met spaties ertussen).\n        * Retourneer de vertaalde zin.\n\n3.  **`Hoofdklasse`:**\n    * Bevat `main` methode.\n    * Maak een `Woordenboek` aan.\n    * Voeg enkele vertalingen toe (bv. \"mooi\" -> \"nice\", \"pretty\", \"beautiful\"; \"kind\" -> \"child\").\n    * Maak een `Vertaler` aan met het woordenboek.\n    * Vraag de vertaling van de zin \"mooi kind\".\n    * Druk de vertaalde zin af op het scherm.",
    "starter_code": "```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Random;\n\n// Klasse Woordenboek\npublic class Woordenboek {\n    private Map<String, ArrayList<String>> woorden;\n    private Random randomGenerator;\n\n    public Woordenboek() {\n        // TODO: Initialiseer map en randomGenerator\n    }\n\n    public void voegVertalingToe(String nederlandsWoord, String engelseVertaling) {\n        // TODO: Implementatie\n    }\n\n    public String geefWillekeurigeVertaling(String nederlandsWoord) {\n        // TODO: Implementatie\n        return \"\"; // Placeholder\n    }\n}\n\n// Klasse Vertaler\npublic class Vertaler {\n    private Woordenboek woordenboek;\n\n    public Vertaler(Woordenboek woordenboek) {\n        // TODO: Initialiseer attribuut\n    }\n\n    public String vertaalZin(String zin) {\n        // TODO: Implementatie\n        return \"\"; // Placeholder\n    }\n}\n\n// Klasse Hoofdklasse\npublic class Hoofdklasse {\n    public static void main(String[] args) {\n        // TODO: Implementeer test scenario\n    }\n}\n```",
    "hints": [
      "Gebruik `woorden.containsKey(nederlandsWoord)` om te checken of een woord al bestaat.",
      "Gebruik `woorden.get(nederlandsWoord)` om de lijst op te halen.",
      "Gebruik `new ArrayList<>()` om een nieuwe lijst te maken.",
      "Gebruik `woorden.put(nederlandsWoord, nieuweLijst)` om een nieuw woord toe te voegen.",
      "Voor willekeurige keuze: `int index = randomGenerator.nextInt(lijst.size()); String vertaling = lijst.get(index);`",
      "Gebruik `StringBuilder` of `StringJoiner` voor efficiënte string concatenatie in `vertaalZin`."
    ],
    "solution": null,
    "testing_info": "Voer de `Hoofdklasse` uit. Controleer of de output een correcte vertaling is (bv. \"beautiful child\", \"nice child\", \"pretty child\"). Test eventueel met woorden die niet in het woordenboek staan.",
    "required_files": []
  },
  // Entry for H6.4i
  "H6.4i": {
    "id": "H6.4i",
    "title": "Database",
    "detailed_description": "## Oefening: Simulatie Database met HashMaps\n\nSimuleer een relationele database met twee tabellen (Klant en Order) en zorg voor het afdwingen van primary key constraints en referentiële integriteit.\n\n**Databank Structuur:**\n* **Klant Tabel:** `klantnr` (PK, String), `naam` (String), `adres` (String)\n* **Order Tabel:** `ordernr` (PK, String), `omschrijving` (String), `klantnr` (FK naar Klant, String)\n\n**Klassen:**\n\n1.  **`KlantInfo`:**\n    * Attributen: `klantnr`, `naam`, `adres` (allemaal String).\n    * Constructor en getters.\n\n2.  **`OrderInfo`:**\n    * Attributen: `ordernr`, `omschrijving`, `klantnr` (allemaal String).\n    * Constructor en getters.\n\n3.  **`Database`:**\n    * Bevat de data: `HashMap<String, KlantInfo> klanten` (key = klantnr) en `HashMap<String, OrderInfo> orders` (key = ordernr).\n    * Methodes:\n        * `void voegKlantToe(KlantInfo klant)`: Voegt klant toe. Controleert of `klant.getKlantnr()` al bestaat in `klanten`. Indien ja, geef foutmelding.\n        * `void voegOrderToe(OrderInfo order)`: Voegt order toe. Controleert of `order.getOrdernr()` al bestaat in `orders`. Controleert of `order.getKlantnr()` bestaat in `klanten` (referentiële integriteit). Indien een controle faalt, geef foutmelding.\n        * `void printLijstOrders()`: Drukt een lijst af van alle orders met bijhorende klantinformatie. Voor elk order, toon minstens `ordernr`, `omschrijving`, en de `naam` van de klant (opgehaald uit de `klanten` map via `order.getKlantnr()`).\n        * `void verwijderOrder(String ordernr)`: Verwijdert het order met het gegeven `ordernr` uit de `orders` map.\n        * `void verwijderKlant(String klantnr)`: Verwijdert de klant met het gegeven `klantnr` uit de `klanten` map. Controleert *eerst* of er nog orders bestaan voor deze klant in de `orders` map. Indien ja, geef foutmelding en verwijder de klant niet (referentiële integriteit bij delete).\n    * Bij fouten (PK constraint, FK constraint), druk een duidelijke melding af op de console.",
    "starter_code": "```java\nimport java.util.HashMap;\nimport java.util.Map;\n\n// Klasse KlantInfo\npublic class KlantInfo {\n    private final String klantnr;\n    private final String naam;\n    private final String adres;\n\n    public KlantInfo(String klantnr, String naam, String adres) {\n        // TODO: Initialiseer attributen\n    }\n    // TODO: Getters...\n    public String getKlantnr() { /*...*/ return null; }\n    public String getNaam() { /*...*/ return null; }\n    public String getAdres() { /*...*/ return null; }\n}\n\n// Klasse OrderInfo\npublic class OrderInfo {\n    private final String ordernr;\n    private final String omschrijving;\n    private final String klantnr; // Foreign Key\n\n    public OrderInfo(String ordernr, String omschrijving, String klantnr) {\n        // TODO: Initialiseer attributen\n    }\n    // TODO: Getters...\n    public String getOrdernr() { /*...*/ return null; }\n    public String getOmschrijving() { /*...*/ return null; }\n    public String getKlantnr() { /*...*/ return null; }\n}\n\n// Klasse Database\npublic class Database {\n    private Map<String, KlantInfo> klanten = new HashMap<>();\n    private Map<String, OrderInfo> orders = new HashMap<>();\n\n    public void voegKlantToe(KlantInfo klant) {\n        // TODO: Implementatie (incl. PK check)\n    }\n\n    public void voegOrderToe(OrderInfo order) {\n        // TODO: Implementatie (incl. PK & FK check)\n    }\n\n    public void printLijstOrders() {\n        // TODO: Implementatie (join logic)\n    }\n\n    public void verwijderOrder(String ordernr) {\n        // TODO: Implementatie\n    }\n\n    public void verwijderKlant(String klantnr) {\n        // TODO: Implementatie (incl. FK check before delete)\n    }\n\n    // Hoofdklasse voor testen (kan hier of apart)\n    public static void main(String[] args) {\n        Database db = new Database();\n        // TODO: Implementeer test scenario's...\n    }\n}\n```",
    "hints": [
      "Gebruik `map.containsKey(key)` om te controleren of een sleutel al bestaat (PK check).",
      "Bij het toevoegen van een order, controleer *eerst* of de klant bestaat (`klanten.containsKey(order.getKlantnr())`) voordat je de order PK check doet.",
      "Voor `printLijstOrders`, haal de `KlantInfo` op uit de `klanten` map voor elke order om de naam te vinden: `KlantInfo klant = klanten.get(order.getKlantnr());` (check of `klant` niet `null` is).",
      "Voor `verwijderKlant`, moet je door *alle* waarden (`orders.values()`) van de orders map itereren om te zien of een order naar de te verwijderen klant verwijst."
    ],
    "solution": null,
    "testing_info": "Test in de `main` methode: voeg klanten toe, voeg orders toe (ook met ongeldige klantnummers), probeer klanten/orders met bestaande nummers toe te voegen, druk de orderlijst af, verwijder orders, probeer klanten te verwijderen die nog orders hebben, verwijder klanten zonder orders.",
    "required_files": []
  },
  // Entry for H6.5i
  "H6.5i": {
    "id": "H6.5i",
    "title": "Lotto",
    "detailed_description": "## Oefening: Lottogetallen Generatie (zonder arrays)\n\nOntwerp een klasse `Lotto` die 6 unieke lottogetallen genereert, plus 1 uniek reservegetal. Gebruik hiervoor klassen uit `java.util` (zoals `Set`, `List`, `Random`), maar **geen** arrays.\n\n**Vereisten:**\n\n1.  **Klasse `Lotto`:**\n    * Attributen om de 6 winnende getallen en het reservegetal op te slaan (bv. een `Set<Integer>` voor de 6 en een `Integer` voor het reservegetal).\n    * Constructor: Genereert de 6 unieke winnende getallen en 1 uniek reservegetal (dat verschilt van de 6 winnende). Ga uit van een standaard lottobereik, bv. getallen van 1 t/m 45.\n    * Methode `void genereerNieuweCombinatie()`: Genereert een nieuwe set van 6+1 winnende getallen en vervangt de huidige.\n    * Methode `String getWinnendeNummersAlsString()`: Retourneert een String representatie van de 6 winnende getallen en het reservegetal (bv. \"Winnende nummers: [1, 7, 15, 22, 30, 41], Reserve: 12\").\n\n**Beperking:** Gebruik geen arrays (`int[]`) voor het opslaan of genereren van de getallen.",
    "starter_code": "```java\nimport java.util.HashSet;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\npublic class Lotto {\n    private Set<Integer> winnendeNummers;\n    private Integer reserveNummer;\n    private Random randomGenerator;\n    private static final int MAX_NUMMER = 45; // Voorbeeld: Lotto 1-45\n    private static final int AANTAL_WINNENDE = 6;\n\n    public Lotto() {\n        // TODO: Initialiseer randomGenerator en roep genereerNieuweCombinatie() aan\n    }\n\n    public void genereerNieuweCombinatie() {\n        // TODO: Implementatie (gebruik Set en Random, geen arrays)\n        // 1. Maak winnendeNummers leeg (nieuwe HashSet)\n        // 2. Genereer 6 unieke nummers en voeg toe aan Set\n        // 3. Genereer reserveNummer (uniek t.o.v. winnendeNummers)\n    }\n\n    public String getWinnendeNummersAlsString() {\n        // TODO: Implementatie (formatteer Set en reserveNummer naar String)\n        return \"\"; // Placeholder\n    }\n\n    // Hoofdklasse voor testen\n    public static void main(String[] args) {\n        // TODO: Implementeer test scenario\n    }\n}\n```",
    "hints": [
      "Gebruik een `HashSet<Integer>` om de 6 winnende nummers op te slaan; `add()` voegt alleen toe als het element nog niet bestaat, wat uniciteit garandeert.",
      "Gebruik `randomGenerator.nextInt(MAX_NUMMER) + 1` om een getal tussen 1 en `MAX_NUMMER` (inclusief) te krijgen.",
      "Genereer getallen in een `while`-lus totdat de `Set` de gewenste grootte heeft (`AANTAL_WINNENDE`).",
      "Genereer het reservegetal in een `do-while`-lus totdat je een getal vindt dat *niet* in de `Set` van winnende nummers zit (`!winnendeNummers.contains(reserveNummer)`)."
    ],
    "solution": null,
    "testing_info": "Voer de `main` methode uit. Controleer of er 6 unieke winnende nummers en 1 reserve nummer worden getoond, binnen het verwachte bereik (1-45). Controleer of `genereerNieuweCombinatie()` een andere set getallen produceert.",
    "required_files": []
  },
  // Entry for H6.6i+
  "H6.6i+": {
    "id": "H6.6i+",
    "title": "Balls",
    "detailed_description": "## Oefening: Balls+ Uitdaging\n\nDeze oefening bouwt verder op een startproject met stuiterende ballen.\n\n**Vooraf:** Open het startproject (bevat `Canvas.java`, `BouncingBall.java`, `BallDemo.java`, `Main.java`) in IntelliJ. Voer `Main.main()` uit en bestudeer `BallDemo.drawDemo()`.\n\n**Deel 1: Meerdere Stuiterende Ballen**\n\n1.  **Wijzig `BallDemo.bounce()`:**\n    * Voeg een parameter `int aantalBallen` toe.\n    * Maak `aantalBallen` `BouncingBall` objecten aan (beperk tot bv. 6).\n    * Sla deze ballen op in een geschikte container (`ArrayList`, `HashMap`, of `HashSet` - kies de meest logische).\n    * Zorg ervoor dat de `draw()` en `move()` methodes van *alle* ballen in de container worden aangeroepen in de animatielus.\n    * Plaats de ballen initieel op een rijtje bovenaan het canvas.\n2.  **Willekeurige Startpositie & Kleur:**\n    * Pas `bounce()` verder aan zodat de ballen op een *willekeurige* x-positie bovenaan het canvas starten.\n    * Geef elke bal een *willekeurige* kleur.\n\n**Deel 2: Ballen in een Box**\n\n1.  **Maak Nieuwe Klasse `BoxBall`:**\n    * Deze klasse stelt een bal voor die *binnen* een rechthoek beweegt.\n    * Attributen: positie (x, y), snelheid (dx, dy), kleur, radius.\n    * Methodes: `draw(Canvas canvas)`, `move()`, constructor.\n2.  **Maak Nieuwe Methode `BallDemo.boxBounce(int aantalBallen)`:**\n    * Tekent een blauwe rechthoek (de \"box\") op het canvas.\n    * Maakt `aantalBallen` `BoxBall` objecten aan (beperk tot bv. 15).\n    * Sla deze ballen op in een geschikte container.\n    * Elke bal moet een willekeurige startpositie *binnen* de box, willekeurige snelheid/richting en willekeurige kleur hebben.\n    * Implementeer de animatielus:\n        * Teken de box.\n        * Voor elke bal: `move()` en `draw()`.\n        * Implementeer botsingsdetectie met de randen van de *box*. Als een bal een rand raakt, keer de relevante snelheidscomponent (dx of dy) om.\n        * Zorg dat de randen van de box altijd zichtbaar blijven (ballen mogen er niet overheen tekenen).\n        * Voeg een kleine pauze toe in de lus (`canvas.wait(50)`).",
    "starter_code": "```java\n// Aannames: Klassen Canvas, BouncingBall, BallDemo, Main zijn beschikbaar\n// uit het startproject.\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\n// In klasse BallDemo:\npublic class BallDemo {\n    private Canvas canvas;\n    private Random randomGenerator = new Random();\n    // ... (bestaande attributen/constructor) ...\n\n    public void bounce(int aantalBallen) {\n        // TODO: Implementatie Deel 1\n        // - Maak container (bv. List<BouncingBall>)\n        // - Maak 'aantalBallen' BouncingBall objecten met random x-pos/kleur\n        // - Voeg toe aan container\n        // - Start animatielus\n        //   - Roep move() aan voor elke bal in container\n        //   - Check stopconditie\n        //   - Wacht (canvas.wait)\n    }\n\n    // --- Deel 2 --- \n    \n    // Nieuwe inner class of aparte class BoxBall\n    private class BoxBall {\n        // TODO: Attributen (x, y, radius, color, dx, dy, canvas, box bounds)\n        \n        public BoxBall(/*... params ...*/) {\n            // TODO: Initialiseer attributen\n        }\n\n        public void draw() {\n            // TODO: Teken bal op canvas\n        }\n\n        public void erase() {\n            // TODO: Wis bal van canvas\n        }\n\n        public void move() {\n            // TODO: Implementatie\n            // - Wis oude positie (erase)\n            // - Update x, y met dx, dy\n            // - Check botsing met box randen (minX, maxX, minY, maxY)\n            // - Keer dx/dy om bij botsing\n            // - Teken nieuwe positie (draw)\n        }\n    }\n    \n    public void boxBounce(int aantalBallen) {\n        // TODO: Implementatie Deel 2\n        // - Definieer box grenzen\n        // - Maak container (bv. List<BoxBall>)\n        // - Maak 'aantalBallen' BoxBall objecten met random pos/snelheid/kleur binnen box\n        // - Voeg toe aan container\n        // - Start animatielus\n        //   - Teken box\n        //   - Roep move() aan voor elke bal in container\n        //   - Wacht (canvas.wait)\n    }\n}\n```",
    "hints": [
      "Voor deel 1: `ArrayList<BouncingBall>` is waarschijnlijk de beste keuze om de ballen op te slaan.",
      "Gebruik `Random` objecten voor willekeurige posities en kleuren.",
      "Voor deel 2: Definieer de grenzen van de box (min/max x en y).",
      "In de `move()` methode van `BoxBall`, controleer of `xPosition +/- radius` buiten de box grenzen valt, en idem voor `yPosition`. Keer `xSpeed` of `ySpeed` om bij botsing.",
      "Zorg dat de startpositie van `BoxBall` willekeurig is, maar wel *binnen* de box grenzen.",
      "De animatielus voor `boxBounce` moet continu lopen (of tot een stopconditie)."
    ],
    "solution": null,
    "testing_info": "Voer `Main.main()` uit om de originele werking te zien. Roep `ballDemo.bounce(aantal)` aan met verschillende aantallen (bv. 3, 6) en observeer. Roep `ballDemo.boxBounce(aantal)` aan met verschillende aantallen (bv. 5, 15) en observeer de ballen die binnen de blauwe rechthoek stuiteren.",
    "required_files": ["Canvas.java", "BouncingBall.java", "BallDemo.java", "Main.java"] // From start project
  },
  // New entry for H8.1
  "H8.1": {
    "id": "H8.1",
    "title": "Jas",
    "detailed_description": "## Oefening: Klasse Jas met Enums\n\nOntwerp een klasse `Jas` om informatie over jassen bij te houden.\n\n**Vereisten:**\n\n1.  **Enum `Maat`:**\n    * Definieer een `enum Maat` met de waarden: `S`, `M`, `L`, `XL`, `XXL`.\n    * Koppel eventueel de numerieke maten (38, 40, 42, 44, 46) aan deze enum-waarden (bv. via een attribuut en/of methode in de enum).\n\n2.  **Enum `Kleur`:**\n    * Definieer een `enum Kleur` met de waarden: `ROOD`, `BLAUW`, `GROEN`, `GRIJS`, `BEIGE`, `ZWART`.\n\n3.  **Klasse `Jas`:**\n    * Attributen: `maat` (type `Maat`), `kleur` (type `Kleur`), `prijs` (double).\n    * Constructor om een `Jas` object aan te maken met maat, kleur en prijs.\n    * `toString()` methode: Geeft een string representatie terug die de kleur, maat en prijs van de jas toont.\n\n4.  **Klasse `Hoofdklasse`:**\n    * Bevat `main` methode.\n    * Maak een `ArrayList<Jas>` genaamd `kledingrek`.\n    * Maak een aantal `Jas` objecten aan met verschillende maten en kleuren.\n    * Voeg deze jassen toe aan het `kledingrek`.\n    * **Output:**\n        * Druk eerst alle mogelijke waarden van de `Maat` enum af, met vermelding van de bijhorende numerieke grootte.\n        * Druk daarna alle mogelijke waarden van de `Kleur` enum af.\n        * Druk tenslotte alle `Jas` objecten uit het `kledingrek` af (gebruik makend van de `toString()` methode).",
    "starter_code": "```java\nimport java.util.ArrayList;\nimport java.util.List;\n\n// Enum Maat\nenum Maat {\n    // TODO: Definieer enum constanten (S, M, ...)\n    // Optioneel: voeg attribuut en constructor toe voor numerieke maat\n    S(38), M(40), L(42), XL(44), XXL(46); // Voorbeeld met numerieke maat\n    private final int numMaat;\n    Maat(int n) { this.numMaat = n; }\n    public int getNumeriekeMaat() { return numMaat; }\n}\n\n// Enum Kleur\nenum Kleur {\n    // TODO: Definieer enum constanten (ROOD, BLAUW, ...)\n    ROOD, BLAUW, GROEN, GRIJS, BEIGE, ZWART\n}\n\n// Klasse Jas\npublic class Jas {\n    private Maat maat;\n    private Kleur kleur;\n    private double prijs;\n\n    public Jas(Maat maat, Kleur kleur, double prijs) {\n        // TODO: Initialiseer attributen\n    }\n\n    @Override\n    public String toString() {\n        // TODO: Implementeer toString zoals gevraagd\n        return \"\"; // Placeholder\n    }\n\n    // TODO: Getters indien nodig...\n}\n\n// Klasse Hoofdklasse\npublic class Hoofdklasse {\n    public static void main(String[] args) {\n        // TODO: Implementeer test scenario\n        // - Maak ArrayList kledingrek\n        // - Maak Jas objecten\n        // - Voeg toe aan kledingrek\n        // - Print alle maten (met numerieke waarde)\n        // - Print alle kleuren\n        // - Print alle jassen in kledingrek\n    }\n}\n```",
    "hints": [
      "Definieer de enums `Maat` en `Kleur` bovenaan of in aparte bestanden.",
      "Je kan een attribuut en constructor toevoegen aan de `Maat` enum om de numerieke waarde op te slaan.",
      "Gebruik `Enum.values()` om een array te krijgen van alle constanten in een enum, waar je dan overheen kan itereren.",
      "Formatter de prijs netjes in de `toString()` methode, bv. met `String.format(\"%.2f\", prijs)`."
    ],
    "solution": null,
    "testing_info": "Voer de `main` methode uit. Controleer of de output correct de lijst van maten met numerieke waarden, de lijst van kleuren, en de details van de aangemaakte jassen weergeeft.",
    "required_files": []
  },
  // New entry for H8.2
  "H8.2": {
    "id": "H8.2",
    "title": "KrokoLoko",
    "detailed_description": "## Oefening: Kroko Loko Spel Simulatie\n\nImplementeer een geautomatiseerde simulatie van het bordspel Kroko Loko voor 2 spelers.\n\n**Spel Overzicht:**\n* **Doel:** Verzamel de meeste dierenkaartjes om de langste krokodil te vormen.\n* **Componenten:** Krokodillen (kop/staart), 28 dierenkaartjes (land/lucht/water), 1 speciale dobbelsteen.\n* **Setup:** Spelers krijgen kop/staart. Kaartjes geschud en gedekt op tafel. Startspeler willekeurig gekozen.\n* **Spelverloop (per beurt):**\n    1.  Speler gooit dobbelsteen.\n    2.  Voert actie uit gebaseerd op worp:\n        * **Land/Lucht/Water Dier:** Draai 1 kaart om. Indien type overeenkomt, voeg kaart toe aan eigen krokodil. Anders, draai kaart terug.\n        * **Keuze (Joker):** Neem willekeurige kaart van tafel en voeg toe aan eigen krokodil.\n        * **Lachende Kroko:** Steel willekeurige kaart van tegenstander (indien mogelijk) en voeg toe aan eigen krokodil.\n        * **Tandpijn Kroko:** Sla beurt over.\n    3.  Andere speler is aan de beurt.\n* **Einde:** Spel stopt als alle kaarten van tafel zijn. Speler met meeste kaarten wint (gelijkspel mogelijk).\n* **Automatisering:** Alle keuzes (startspeler, kaart kiezen, kaart stelen) gebeuren willekeurig (gebruik `java.util.Random`). Het memory aspect vervalt.\n\n**Implementatie Vereisten:**\n\n1.  **Klassen:** Ontwerp geschikte klassen (bv. `Speler`, `Kaart`, `Dobbelsteen`, `Spel`).\n    * `Kaart`: Type dier (LAND, LUCHT, WATER), eventueel naam van dier.\n    * `Dobbelsteen`: Mogelijke worpen (enum), methode `rol()` die willekeurige worp retourneert.\n    * `Speler`: Naam, verzameling verzamelde kaarten (`ArrayList<Kaart>`).\n    * `Spel`: Beheert 2 spelers, de stapel kaarten op tafel (`ArrayList<Kaart>`), de huidige speler, de game loop.\n2.  **Input:** Vraag namen van 2 spelers op bij start.\n3.  **Output:**\n    * Na elke beurt: Druk naam speler, dobbelsteenworp, genomen actie (bv. welke kaart getrokken/gestolen), en de visuele representatie van *beide* krokodillen af.\n    * Krokodil representatie: `:<` (leeg), `--#:<` (1 kaart), `--##:<` (2 kaarten), etc.\n    * Na einde spel: Druk winnaar(s) af.\n4.  **Willekeur:** Gebruik `java.util.Random` voor alle willekeurige acties.",
    "starter_code": "```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.Scanner;\n\n// TODO: Definieer enum DierType (LAND, LUCHT, WATER)\n// TODO: Definieer enum DobbelsteenWorp (LANDDIER, LUCHTDIER, ...)\n\n// Klasse Kaart\nclass Kaart {\n    // TODO: Attributen (type, naam)\n    // TODO: Constructor\n    // TODO: Getters\n    // TODO: toString (optioneel)\n}\n\n// Klasse Dobbelsteen\nclass Dobbelsteen {\n    // TODO: Attribuut Random\n    // TODO: Methode rol() die random DobbelsteenWorp retourneert\n}\n\n// Klasse Speler\nclass Speler {\n    // TODO: Attributen (naam, List<Kaart>)\n    // TODO: Constructor\n    // TODO: Getters (naam, aantal kaarten)\n    // TODO: Methode voegKaartToe(Kaart kaart)\n    // TODO: Methode verwijderWillekeurigeKaart() (let op lege lijst)\n    // TODO: Methode getKrokodilWeergave() die string retourneert\n}\n\n// Klasse Spel\nclass Spel {\n    // TODO: Attributen (List<Speler>, List<Kaart> tafelKaarten, Dobbelsteen, Random, huidigeSpelerIndex)\n\n    public Spel(String naamSpeler1, String naamSpeler2) {\n        // TODO: Initialiseer spelers, maak kaarten aan, shuffle, kies startspeler\n    }\n\n    private void maakStartKaarten() {\n        // TODO: Vul tafelKaarten met 28 kaarten\n    }\n\n    public void speel() {\n        // TODO: Implementeer game loop (while !tafelKaarten.isEmpty())\n        // - speelBeurt()\n        // - wisselSpeler()\n        // - toonEindResultaat()\n    }\n\n    private void speelBeurt() {\n        // TODO: Implementeer logica voor één beurt\n        // - Haal huidige speler op\n        // - Rol dobbelsteen\n        // - Print speler naam en worp\n        // - Voer actie uit gebaseerd op worp (switch statement)\n        //   - Kaart kiezen/stelen (gebruik Random)\n        //   - Kaart toevoegen/verwijderen bij spelers\n        // - Print actie info\n        // - Print krokodillen (roep toonKrokodillen() aan)\n    }\n\n    private void wisselSpeler() {\n        // TODO: Update huidigeSpelerIndex\n    }\n\n    private void toonKrokodillen() {\n        // TODO: Print de krokodil weergave voor beide spelers\n    }\n\n     private void toonEindResultaat() {\n        // TODO: Bepaal winnaar(s) en print resultaat\n    }\n\n    public static void main(String[] args) {\n        // TODO: Implementeer start van het spel\n        // - Vraag namen op (Scanner)\n        // - Maak Spel object aan\n        // - Roep spel.speel() aan\n    }\n}\n\n```",
    "hints": [
      "Gebruik enums voor `DierType` en `DobbelsteenWorp`.",
      "Gebruik `ArrayList<Kaart>` voor de kaarten op tafel en de kaarten per speler.",
      "Gebruik `Collections.shuffle(tafelKaarten)` aan het begin.",
      "Implementeer de logica voor elke dobbelsteenworp zorgvuldig.",
      "Let op randgevallen: lege tafel, tegenstander heeft geen kaarten om te stelen.",
      "Gebruik `Random` voor het kiezen van een kaart van tafel of van de tegenstander.",
      "Bouw de krokodil-string dynamisch op basis van `speler.getAantalKaarten()`."
    ],
    "solution": null,
    "testing_info": "Start het spel via de `main` methode. Geef spelernamen op. Volg de output op de console: controleer of beurten wisselen, of de dobbelsteenworpen en acties logisch zijn, of de krokodillen correct groeien/krimpen, en of de winnaar correct bepaald wordt.",
    "required_files": []
  }
  // Entry for H10.1
  "H10.1": {
    "id": "H10.1",
    "title": "Watersportclub_Zeil-enMotorboten",
    "detailed_description": "## Oefening: Watersportclub met Zeil- en Motorboten\n\nDeze oefening breidt een eerdere watersportclub-oefening uit met verschillende boottypes en een prijsberekening inclusief toeslagen en kortingen.\n\n**Context:**\nEen watersportclub verhuurt boten aan leden. Er zijn nu zeil- en motorboten met verschillende opties en bijhorende prijstoeslagen.\n\n**Vereisten:**\n\n1.  **Klasse `Lid`:**\n    * Attributen: `naam` (String), `telefoonnummer` (String) (beide onveranderlijk na creatie).\n    * Attribuut: `kortingsPercentage` (double, aanpasbaar na creatie).\n    * Constructor en getters/setters waar nodig.\n\n2.  **Boot Hiërarchie (Overerving):**\n    * **Superklasse `Boot`:**\n        * Attributen: `naam` (String), `prijs` (double, basisprijs per uur), `heeftRadar` (boolean).\n        * Methode (bv. abstract of met basisimplementatie) om de prijs per uur te berekenen, inclusief 5% toeslag voor radar indien `heeftRadar` true is.\n    * **Subklasse `Zeilboot` extends `Boot`:**\n        * Extra attribuut: `heeftGPS` (boolean).\n        * Overschrijft prijsberekeningsmethode: Voegt 3% toeslag toe indien `heeftGPS` true is (bovenop eventuele radar toeslag).\n    * **Subklasse `Motorboot` extends `Boot`:**\n        * Extra attribuut: `heeftFishfinder` (boolean).\n        * Overschrijft prijsberekeningsmethode: Voegt 7% toeslag toe indien `heeftFishfinder` true is (bovenop eventuele radar toeslag).\n\n3.  **Klasse `Reservatie`:**\n    * Attributen: `lid` (type `Lid`), `boot` (type `Boot`), `aantalUren` (double, aanpasbaar na creatie).\n    * Constructor.\n    * Methode `double berekenPrijs()`: Berekent de totale kost van de reservatie.\n        * Haalt de prijs per uur op van de `boot` (die rekening houdt met radar/gps/fishfinder toeslagen).\n        * Vermenigvuldigt met `aantalUren`.\n        * Past de `kortingsPercentage` van het `lid` toe.\n        * Retourneert de eindprijs.\n\n4.  **Klasse `Main` (of `Hoofdklasse`):**\n    * Bevat `main` methode.\n    * Maak verschillende `Zeilboot` en `Motorboot` objecten aan (met en zonder opties).\n    * Maak verschillende `Lid` objecten aan (met verschillende kortingspercentages).\n    * Maak `Reservatie` objecten aan die leden en boten koppelen voor een bepaald aantal uren.\n    * Bereken en druk de totale prijs af voor elke reservatie.",
    "starter_code": "```java\n// Klasse Lid\npublic class Lid {\n    private final String naam;\n    private final String telefoonnummer;\n    private double kortingsPercentage; // bv. 0.05 voor 5%\n\n    public Lid(String naam, String telefoonnummer, double kortingsPercentage) {\n        // TODO: Initialiseer attributen\n    }\n\n    // TODO: Getters (naam, telefoonnummer, kortingsPercentage)\n    // TODO: Setter voor kortingsPercentage\n}\n\n// Abstracte Superklasse Boot\nabstract class Boot {\n    protected String naam;\n    protected double prijsPerUur;\n    protected boolean heeftRadar;\n    protected static final double RADAR_TOESLAG = 0.05; // 5%\n\n    public Boot(String naam, double prijsPerUur, boolean heeftRadar) {\n        // TODO: Initialiseer attributen\n    }\n\n    // Methode om basisprijs incl. radar te berekenen\n    public double getBasisPrijsMetToeslagen() {\n        double prijs = prijsPerUur;\n        if (heeftRadar) {\n            prijs *= (1 + RADAR_TOESLAG);\n        }\n        return prijs;\n    }\n\n    // Abstracte methode of override in subclasses voor specifieke toeslagen\n    public abstract double getTotalePrijsPerUur();\n\n    // TODO: Getters\n}\n\n// Subklasse Zeilboot\nclass Zeilboot extends Boot {\n    private boolean heeftGPS;\n    private static final double GPS_TOESLAG = 0.03; // 3%\n\n    public Zeilboot(String naam, double prijsPerUur, boolean heeftRadar, boolean heeftGPS) {\n        // TODO: Roep super constructor aan, initialiseer heeftGPS\n        super(naam, prijsPerUur, heeftRadar);\n        this.heeftGPS = heeftGPS;\n    }\n\n    @Override\n    public double getTotalePrijsPerUur() {\n        double basisPrijs = super.getBasisPrijsMetToeslagen();\n        if (heeftGPS) {\n            basisPrijs *= (1 + GPS_TOESLAG);\n        }\n        return basisPrijs;\n    }\n    // TODO: Getters\n}\n\n// Subklasse Motorboot\nclass Motorboot extends Boot {\n    private boolean heeftFishfinder;\n    private static final double FISHFINDER_TOESLAG = 0.07; // 7%\n\n    public Motorboot(String naam, double prijsPerUur, boolean heeftRadar, boolean heeftFishfinder) {\n        // TODO: Roep super constructor aan, initialiseer heeftFishfinder\n         super(naam, prijsPerUur, heeftRadar);\n         this.heeftFishfinder = heeftFishfinder;\n    }\n\n    @Override\n    public double getTotalePrijsPerUur() {\n        double basisPrijs = super.getBasisPrijsMetToeslagen();\n        if (heeftFishfinder) {\n            basisPrijs *= (1 + FISHFINDER_TOESLAG);\n        }\n        return basisPrijs;\n    }\n     // TODO: Getters\n}\n\n// Klasse Reservatie\npublic class Reservatie {\n    private Lid lid;\n    private Boot boot;\n    private double aantalUren;\n\n    public Reservatie(Lid lid, Boot boot, double aantalUren) {\n        // TODO: Initialiseer attributen\n    }\n\n    // TODO: Getter/Setter voor aantalUren\n\n    public double berekenPrijs() {\n        // TODO: Implementeer prijsberekening\n        // 1. Haal totale prijs per uur op van boot (boot.getTotalePrijsPerUur())\n        // 2. Vermenigvuldig met aantalUren\n        // 3. Pas korting toe (prijs * (1 - lid.getKortingsPercentage()))\n        // 4. Retourneer eindprijs\n        return 0.0; // Placeholder\n    }\n}\n\n// Klasse Main\npublic class Main {\n    public static void main(String[] args) {\n        // TODO: Implementeer test scenario\n        // - Maak boten (Zeilboot, Motorboot) met/zonder opties\n        // - Maak leden met/zonder korting\n        // - Maak reservaties\n        // - Bereken en print de prijs voor elke reservatie\n    }\n}\n```",
    "hints": [
      "Gebruik een abstracte klasse `Boot` of een concrete klasse met een (abstracte) methode voor de prijsberekening die subclasses kunnen overschrijven.",
      "Roep `super()` aan in de constructors van de subclasses.",
      "De prijsberekening in `Reservatie` combineert de informatie van `Boot` (prijs + toeslagen) en `Lid` (korting).",
      "Let op met het correct toepassen van percentages (bv. `prijs * (1 + toeslagPercentage)` en `prijs * (1 - kortingsPercentage)`)."
    ],
    "solution": null,
    "testing_info": "Maak in `Main` testgevallen die alle combinaties van boottypes, opties (radar, GPS, fishfinder) en lidkortingen dekken. Controleer handmatig of de berekende reservatieprijzen correct zijn.",
    "required_files": []
  },
  // New entry for H11.1
  "H11.1": {
    "id": "H11.1",
    "title": "Watersportclub_GoudenLeden",
    "detailed_description": "## Oefening: Watersportclub met Gouden Leden\n\nDeze oefening is een uitbreiding op H10.1 (Watersportclub met Zeil- en Motorboten).\n\n**Doel:** Introduceer twee verschillende types leden (`GewoonLid` en `GoudenLid`) met verschillende kortingsregels, ter vervanging van de enkele `Lid` klasse uit H10.1.\n\n**Vereisten:**\n\n1.  **Leden Hiërarchie (Overerving):**\n    * **Superklasse `Lid`:**\n        * Attributen: `naam` (String, final), `telefoonnummer` (String, final).\n        * Constructor.\n        * Methode (bv. `getKortingPercentage()`) die standaard 0% korting retourneert.\n    * **Subklasse `GewoonLid` extends `Lid`:**\n        * Geen extra attributen of specifiek gedrag nodig t.o.v. de basis `Lid` (erft 0% korting).\n    * **Subklasse `GoudenLid` extends `Lid`:**\n        * Extra attribuut: `aantalAandelen` (int, mutable).\n        * Constructor (roept super constructor aan, initialiseert aandelen).\n        * Setter voor `aantalAandelen`.\n        * Overschrijft de `getKortingPercentage()` methode om 0.05 (5%) te retourneren.\n\n2.  **Aanpassing `Reservatie` Klasse:**\n    * De `Reservatie` klasse (uit H10.1) moet nu werken met de `Lid` superklasse (of subclasses).\n    * De methode `berekenPrijs()` in `Reservatie` moet aangepast worden: in plaats van een `kortingsPercentage` attribuut direct uit `Lid` te lezen, moet het nu de `getKortingPercentage()` methode van het `Lid` object aanroepen om de correcte korting (0% of 5%) te krijgen en toe te passen.\n\n3.  **Klasse `Main` (of `Hoofdklasse`):**\n    * Pas de `main` methode uit H10.1 aan.\n    * Maak nu `GewoonLid` en `GoudenLid` objecten aan in plaats van `Lid` objecten.\n    * Maak `Reservatie` objecten aan met beide types leden.\n    * Bereken en druk de totale prijs af voor elke reservatie en verifieer dat de korting correct wordt toegepast.",
    "starter_code": "```java\n// Aannames: Klassen Boot, Zeilboot, Motorboot, Reservatie, Main uit H10.1 zijn beschikbaar.\n\n// Superklasse Lid (kan abstract zijn)\nabstract class Lid {\n    protected final String naam;\n    protected final String telefoonnummer;\n\n    public Lid(String naam, String telefoonnummer) {\n        this.naam = naam;\n        this.telefoonnummer = telefoonnummer;\n    }\n\n    // Getters voor naam en telefoonnummer\n    public String getNaam() { return naam; }\n    public String getTelefoonnummer() { return telefoonnummer; }\n\n    /**\n     * Geeft het kortingspercentage voor dit type lid.\n     * @return double Het kortingspercentage (bv. 0.0 voor 0%, 0.05 voor 5%).\n     */\n    public abstract double getKortingPercentage(); \n    // Of maak Lid concreet en retourneer hier 0.0, override in GoudenLid\n}\n\n// Subklasse GewoonLid\nclass GewoonLid extends Lid {\n    public GewoonLid(String naam, String telefoonnummer) {\n        super(naam, telefoonnummer);\n    }\n\n    @Override\n    public double getKortingPercentage() {\n        return 0.0; // Gewone leden krijgen geen korting\n    }\n}\n\n// Subklasse GoudenLid\nclass GoudenLid extends Lid {\n    private int aantalAandelen;\n    private static final double KORTING = 0.05; // 5%\n\n    public GoudenLid(String naam, String telefoonnummer, int aantalAandelen) {\n        super(naam, telefoonnummer);\n        this.aantalAandelen = aantalAandelen;\n    }\n\n    public int getAantalAandelen() { return aantalAandelen; }\n    public void setAantalAandelen(int aantalAandelen) { this.aantalAandelen = aantalAandelen; }\n\n    @Override\n    public double getKortingPercentage() {\n        return KORTING; // Gouden leden krijgen 5% korting\n    }\n}\n\n// Aanpassing nodig in Klasse Reservatie (uit H10.1)\n/*\npublic class Reservatie {\n    private Lid lid; // Type is nu de superklasse\n    private Boot boot;\n    private double aantalUren;\n\n    // Constructor blijft hetzelfde\n    public Reservatie(Lid lid, Boot boot, double aantalUren) { ... }\n\n    // Getter/Setter aantalUren blijft hetzelfde\n\n    public double berekenPrijs() {\n        double basisPrijs = boot.getTotalePrijsPerUur();\n        double totalePrijs = basisPrijs * aantalUren;\n        // Gebruik de methode van het Lid object om korting te bepalen!\n        double korting = lid.getKortingPercentage(); \n        double eindPrijs = totalePrijs * (1 - korting);\n        return eindPrijs;\n    }\n}\n*/\n\n// Aanpassing nodig in Klasse Main (uit H10.1)\n/*\npublic class Main {\n    public static void main(String[] args) {\n        // Maak boten zoals voorheen...\n        Boot zeilbootMetAlles = new Zeilboot(...);\n        Boot motorbootBasis = new Motorboot(...);\n\n        // Maak NU GewoonLid en GoudenLid objecten\n        Lid gewoonLid = new GewoonLid(\"Jan Janssen\", \"0477123456\");\n        Lid goudenLid = new GoudenLid(\"Piet Pieters\", \"0488654321\", 10);\n\n        // Maak reservaties met de nieuwe lid types\n        Reservatie res1 = new Reservatie(gewoonLid, zeilbootMetAlles, 4.0);\n        Reservatie res2 = new Reservatie(goudenLid, motorbootBasis, 2.5);\n\n        // Bereken en print prijzen\n        System.out.println(\"Prijs res1 (gewoon lid): \" + res1.berekenPrijs());\n        System.out.println(\"Prijs res2 (gouden lid): \" + res2.berekenPrijs());\n    }\n}\n*/\n```",
    "hints": [
      "Definieer een duidelijke hiërarchie voor `Lid`, `GewoonLid`, en `GoudenLid`.",
      "Plaats gemeenschappelijke eigenschappen (`naam`, `telefoonnummer`) in de superklasse `Lid`.",
      "Implementeer de kortingslogica via een methode (bv. `getKortingPercentage`) in de `Lid` hiërarchie.",
      "Pas de `berekenPrijs` methode in `Reservatie` aan om deze methode te gebruiken i.p.v. een direct attribuut."
    ],
    "solution": null,
    "testing_info": "Voer de aangepaste `Main` methode uit. Maak reservaties voor zowel `GewoonLid` als `GoudenLid`. Controleer of de berekende prijzen correct de 5% korting toepassen enkel voor de `GoudenLid` reservaties.",
    "required_files": ["Boot.java", "Zeilboot.java", "Motorboot.java", "Reservatie.java", "Main.java"] // Assuming these exist from H10.1
  },
  // New entry for H11.2
  "H11.2": {
    "id": "H11.2",
    "title": "Landbouw",
    "detailed_description": "## Oefening: Landbouwbedrijf Simulatie\n\nModelleer een landbouwbedrijf met verschillende soorten percelen (akkers en weilanden) en bereken de opbrengst.\n\n**Vereisten:**\n\n1.  **Klasse `Landbouwbedrijf`:**\n    * Attributen: `referentienummer` (String, final), `naamBedrijfsvoerder` (String), `adres` (String).\n    * Bevat een collectie (bv. `ArrayList`) van `PerceelGrond` objecten.\n    * Methoden om percelen toe te voegen en te verwijderen.\n    * Methode `double getTotaleOpbrengst()`: Berekent de som van de opbrengsten van alle percelen in de collectie.\n    * `toString()` methode.\n\n2.  **Abstracte Superklasse `PerceelGrond`:**\n    * Attributen: `oppervlakte` (double, in hectare), `referentienummerKadaster` (String, final).\n    * Abstracte methode `double berekenOpbrengst()`.\n    * Constructor en getters.\n    * `toString()` methode.\n\n3.  **Subklasse `Akker` extends `PerceelGrond`:**\n    * Attribuut: `soortVrucht` (String of Enum).\n    * Implementeert `berekenOpbrengst()`: `oppervlakte * coefficient`, waarbij de coëfficiënt afhangt van `soortVrucht`:\n        * Aardappelen: 10200\n        * Rode kool: 11900\n        * Prei: 14500\n        * Bloemkool: 13200\n        * Tarwe: 18300\n        * Bieten: 9800\n    * Constructor.\n    * `toString()` methode.\n\n4.  **Subklasse `Weiland` extends `PerceelGrond`:**\n    * Attributen: `aantalKoeien` (int, mutable), `melkprijs` (double, mutable).\n    * Implementeert `berekenOpbrengst()`: `(aantalKoeien * 10 * 200 * melkprijs) - (oppervlakte * 250.0)`.\n    * Constructor.\n    * Setters voor `aantalKoeien` en `melkprijs`.\n    * `toString()` methode.\n\n5.  **Klasse `Main` (of `Hoofdklasse`):**\n    * Bevat `main` methode.\n    * Maak `Landbouwbedrijf` objecten aan.\n    * Maak `Akker` en `Weiland` objecten aan met verschillende eigenschappen.\n    * Voeg percelen toe aan de landbouwbedrijven.\n    * Roep `getTotaleOpbrengst()` aan en druk de resultaten af.\n    * Gebruik `toString()` om informatie over bedrijven en percelen af te drukken.",
    "starter_code": "```java\nimport java.util.ArrayList;\nimport java.util.List;\n\n// Enum voor VruchtType (optioneel maar aanbevolen)\nenum VruchtType {\n    AARDAPPELEN(10200), RODE_KOOL(11900), PREI(14500), \n    BLOEMKOOL(13200), TARWE(18300), BIETEN(9800);\n    \n    private final double coefficient;\n    VruchtType(double coeff) { this.coefficient = coeff; }\n    public double getCoefficient() { return coefficient; }\n}\n\n// Abstracte superklasse PerceelGrond\nabstract class PerceelGrond {\n    protected final String referentienummerKadaster;\n    protected double oppervlakte; // in hectare\n\n    public PerceelGrond(String refKadaster, double opp) {\n        this.referentienummerKadaster = refKadaster;\n        this.oppervlakte = opp;\n    }\n\n    public abstract double berekenOpbrengst();\n\n    // Getters...\n    public String getReferentienummerKadaster() { return referentienummerKadaster; }\n    public double getOppervlakte() { return oppervlakte; }\n\n    @Override\n    public abstract String toString();\n}\n\n// Subklasse Akker\nclass Akker extends PerceelGrond {\n    private VruchtType soortVrucht; // Gebruik Enum\n\n    public Akker(String refKadaster, double opp, VruchtType vrucht) {\n        super(refKadaster, opp);\n        this.soortVrucht = vrucht;\n    }\n\n    @Override\n    public double berekenOpbrengst() {\n        // TODO: Implementatie (oppervlakte * soortVrucht.getCoefficient())\n        return 0.0; // Placeholder\n    }\n\n    @Override\n    public String toString() {\n        // TODO: Implementatie\n        return \"\"; // Placeholder\n    }\n}\n\n// Subklasse Weiland\nclass Weiland extends PerceelGrond {\n    private int aantalKoeien;\n    private double melkprijs;\n    private static final double MELK_PER_KOE_PER_JAAR = 10.0 * 200.0;\n    private static final double ONDERHOUDSKOST_PER_HA = 250.0;\n\n    public Weiland(String refKadaster, double opp, int koeien, double prijs) {\n        super(refKadaster, opp);\n        this.aantalKoeien = koeien;\n        this.melkprijs = prijs;\n    }\n\n    // Setters voor aantalKoeien en melkprijs\n    public void setAantalKoeien(int aantalKoeien) { this.aantalKoeien = aantalKoeien; }\n    public void setMelkprijs(double melkprijs) { this.melkprijs = melkprijs; }\n    // Getters...\n\n    @Override\n    public double berekenOpbrengst() {\n        // TODO: Implementatie (formule uit opgave)\n        return 0.0; // Placeholder\n    }\n\n    @Override\n    public String toString() {\n        // TODO: Implementatie\n        return \"\"; // Placeholder\n    }\n}\n\n// Klasse Landbouwbedrijf\npublic class Landbouwbedrijf {\n    private final String referentienummer;\n    private String naamBedrijfsvoerder;\n    private String adres;\n    private List<PerceelGrond> percelen = new ArrayList<>();\n\n    public Landbouwbedrijf(String ref, String naam, String adr) {\n        this.referentienummer = ref;\n        this.naamBedrijfsvoerder = naam;\n        this.adres = adr;\n    }\n\n    public void voegPerceelToe(PerceelGrond perceel) { /* TODO */ }\n    public void verwijderPerceel(PerceelGrond perceel) { /* TODO */ }\n    // Of verwijder op basis van referentienummerKadaster\n\n    public double getTotaleOpbrengst() {\n        // TODO: Implementatie (itereer over percelen, sommeer berekenOpbrengst())\n        return 0.0; // Placeholder\n    }\n\n    // Getters/Setters waar nodig...\n\n    @Override\n    public String toString() {\n        // TODO: Implementatie (toon bedrijf info + lijst percelen)\n        return \"\"; // Placeholder\n    }\n}\n\n// Klasse Main\npublic class Main {\n    public static void main(String[] args) {\n        // TODO: Implementeer test scenario\n        // - Maak Landbouwbedrijf\n        // - Maak Akker en Weiland objecten\n        // - Voeg percelen toe\n        // - Bereken en print totale opbrengst\n        // - Print bedrijf/perceel info via toString()\n    }\n}\n```",
    "hints": [
      "Gebruik een abstracte klasse `PerceelGrond` met een abstracte methode `berekenOpbrengst()`.",
      "Laat `Akker` en `Weiland` deze methode implementeren met hun specifieke logica.",
      "Gebruik een `List<PerceelGrond>` in `Landbouwbedrijf`.",
      "De `getTotaleOpbrengst()` methode in `Landbouwbedrijf` kan polymorfisme gebruiken door `berekenOpbrengst()` aan te roepen op elk object in de lijst, ongeacht of het een `Akker` of `Weiland` is.",
      "Overweeg een Enum voor `VruchtType` in `Akker` om de coëfficiënten netjes te beheren."
    ],
    "solution": null,
    "testing_info": "Maak in `Main` een of meerdere landbouwbedrijven aan. Voeg verschillende soorten percelen toe met diverse parameters (oppervlaktes, vruchten, aantal koeien, melkprijzen). Roep `getTotaleOpbrengst()` aan en verifieer de berekening. Druk de `toString()` output af om de status te controleren.",
    "required_files": []
  }
// Entry for H12.1
  "H12.1": {
    "id": "H12.1",
    "title": "Landbouw_MetSchapen",
    "detailed_description": "## Oefening: Landbouw met Schapen\n\nBreid de 'Landbouw' oefening (H11.2) uit met een nieuw type weiland voor schapen en de mogelijkheid om percelen te sorteren op opbrengst.\n\n**Vereisten:**\n\n1.  **Nieuwe Klasse `SchapenWeiland` extends `PerceelGrond`:**\n    * Attribuut: `aantalSchapen` (int, mutable?).\n    * Implementeert `berekenOpbrengst()`:\n        * Opbrengst = `(aantalSchapen * 4 kg_wol/jaar * 0.30 €/kg_wol)`\n        * Kosten = `(oppervlakte * 250.0 €/ha)`\n        * Netto opbrengst = Opbrengst - Kosten.\n    * Constructor.\n    * Setter voor `aantalSchapen`.\n    * `toString()` methode.\n\n2.  **Sorteerbaarheid van Percelen:**\n    * Pas de `PerceelGrond` klasse aan zodat deze `Comparable<PerceelGrond>` implementeert.\n    * Implementeer de `compareTo(PerceelGrond other)` methode. De sortering moet gebaseerd zijn op de berekende opbrengst (`berekenOpbrengst()`).\n\n3.  **Aanpassing `Landbouwbedrijf`:**\n    * Voeg eventueel een methode toe (bv. `printGesorteerdePercelen()`) die de lijst van percelen sorteert op basis van hun opbrengst en vervolgens afdrukt.\n\n4.  **Klasse `Main` (of `Hoofdklasse`):**\n    * Pas de `main` methode uit H11.2 aan.\n    * Maak nu ook `SchapenWeiland` objecten aan en voeg deze toe aan landbouwbedrijven.\n    * Test de opbrengstberekening voor `SchapenWeiland`.\n    * Demonstreer het sorteren van percelen op opbrengst voor een landbouwbedrijf.",
    "starter_code": "```java\n// Aannames: Klassen Landbouwbedrijf, PerceelGrond, Akker, Weiland, Main, VruchtType uit H11.2 zijn beschikbaar.\nimport java.util.Collections;\nimport java.util.List;\n\n// Aanpassing aan PerceelGrond\nabstract class PerceelGrond implements Comparable<PerceelGrond> {\n    protected final String referentienummerKadaster;\n    protected double oppervlakte; // in hectare\n\n    public PerceelGrond(String refKadaster, double opp) {\n        this.referentienummerKadaster = refKadaster;\n        this.oppervlakte = opp;\n    }\n\n    public abstract double berekenOpbrengst();\n\n    // Getters...\n    public String getReferentienummerKadaster() { return referentienummerKadaster; }\n    public double getOppervlakte() { return oppervlakte; }\n\n    @Override\n    public abstract String toString();\n\n    // Implementatie Comparable interface\n    @Override\n    public int compareTo(PerceelGrond other) {\n        // Sorteer op opbrengst (bv. oplopend)\n        // double verschil = this.berekenOpbrengst() - other.berekenOpbrengst();\n        // if (verschil < 0) return -1;\n        // if (verschil > 0) return 1;\n        // return 0;\n        // Of gebruik Double.compare:\n        return Double.compare(this.berekenOpbrengst(), other.berekenOpbrengst());\n    }\n}\n\n// Nieuwe Subklasse SchapenWeiland\nclass SchapenWeiland extends PerceelGrond {\n    private int aantalSchapen;\n    private static final double WOL_OPBRENGST_PER_SCHAAP = 4.0 * 0.30; // kg * €/kg\n    private static final double ONDERHOUDSKOST_PER_HA = 250.0;\n\n    public SchapenWeiland(String refKadaster, double opp, int schapen) {\n        super(refKadaster, opp);\n        this.aantalSchapen = schapen;\n    }\n\n    public void setAantalSchapen(int aantalSchapen) { this.aantalSchapen = aantalSchapen; }\n    public int getAantalSchapen() { return aantalSchapen; }\n\n    @Override\n    public double berekenOpbrengst() {\n        // TODO: Implementatie (formule uit opgave)\n        return 0.0; // Placeholder\n    }\n\n    @Override\n    public String toString() {\n        // TODO: Implementatie\n        return \"\"; // Placeholder\n    }\n}\n\n// Aanpassing aan Landbouwbedrijf\n/*\npublic class Landbouwbedrijf {\n    // ... bestaande attributen en methodes ...\n    private List<PerceelGrond> percelen = new ArrayList<>();\n\n    // ... voegPerceelToe, verwijderPerceel, getTotaleOpbrengst ...\n\n    public void printGesorteerdePercelen() {\n        // Maak een kopie om de originele lijst niet te wijzigen (optioneel)\n        List<PerceelGrond> gesorteerd = new ArrayList<>(percelen);\n        Collections.sort(gesorteerd); // Sorteert op basis van compareTo in PerceelGrond\n        System.out.println(\"Percelen gesorteerd op opbrengst voor \" + referentienummer + \":\");\n        for (PerceelGrond p : gesorteerd) {\n            System.out.println(\"- \" + p + \" (Opbrengst: \" + String.format(\"%.2f\", p.berekenOpbrengst()) + \")\");\n        }\n    }\n    \n    // ... toString ...\n}\n*/\n\n// Aanpassing aan Main\n/*\npublic class Main {\n    public static void main(String[] args) {\n        // ... maak bedrijven, akkers, weilanden ...\n        \n        // Maak SchapenWeiland\n        PerceelGrond schapenwei = new SchapenWeiland(\"SW001\", 10.0, 50);\n        \n        // Voeg toe aan bedrijf\n        // landbouwbedrijf1.voegPerceelToe(schapenwei);\n        \n        // Bereken totale opbrengst (zal nu ook schapenwei meenemen)\n        // System.out.println(\"Totale opbrengst: \" + landbouwbedrijf1.getTotaleOpbrengst());\n        \n        // Print gesorteerde lijst\n        // landbouwbedrijf1.printGesorteerdePercelen();\n    }\n}\n*/\n```",
    "hints": [
      "Maak `SchapenWeiland` een subclass van `PerceelGrond`.",
      "Implementeer de `berekenOpbrengst` formule correct voor schapen.",
      "Laat `PerceelGrond` de `Comparable<PerceelGrond>` interface implementeren.",
      "Implementeer `compareTo` in `PerceelGrond` door de `berekenOpbrengst()` van `this` en `other` te vergelijken.",
      "Gebruik `Collections.sort(lijstVanPercelen)` in `Landbouwbedrijf` om de lijst te sorteren."
    ],
    "solution": null,
    "testing_info": "Voeg `SchapenWeiland` objecten toe aan je test-`Landbouwbedrijf`. Controleer of de opbrengst correct berekend wordt. Roep de sorteermethode aan en verifieer dat de percelen (inclusief schapenweiden) correct gesorteerd op opbrengst worden afgedrukt.",
    "required_files": ["Landbouwbedrijf.java", "PerceelGrond.java", "Akker.java", "Weiland.java", "Main.java", "VruchtType.java"] // Assuming these exist from H11.2
  },
  // Entry for H12.2
  "H12.2": {
    "id": "H12.2",
    "title": "Watersportclub_Pedalo",
    "detailed_description": "## Oefening: Watersportclub Uitbreiden met Pedalo's\n\nBreid de watersportclub-oefening (H11.1 met Gouden Leden) uit met de mogelijkheid om pedalo's te verhuren en reservaties te sorteren op prijs.\n\n**Vereisten:**\n\n1.  **Klasse `Pedalo`:**\n    * Attribuut: `naam` (String).\n    * Geen instrumenten (radar, GPS, fishfinder).\n    * Basishuurprijs: 6.25€ per kwartier (= 25.0€ per uur). Deze prijs moet opvraagbaar en aanpasbaar zijn.\n    * Integratie: `Pedalo` moet in het bestaande systeem passen. Overweeg of het `Boot` kan extenden of dat een interface zoals `Verhuurbaar` nodig is.\n\n2.  **Prijsberekening:**\n    * De `berekenPrijs()` methode in `Reservatie` moet ook werken voor `Pedalo` objecten. De prijs per uur voor een pedalo is 25.0€ (of de aangepaste prijs), zonder verdere toeslagen. De korting van het lid (`GewoonLid` 0%, `GoudenLid` 5%) moet nog steeds worden toegepast.\n\n3.  **Sorteerbaarheid van Reservaties:**\n    * Pas de `Reservatie` klasse aan zodat deze `Comparable<Reservatie>` implementeert.\n    * Implementeer de `compareTo(Reservatie other)` methode. De sortering moet gebaseerd zijn op de berekende totaalprijs (`berekenPrijs()`).\n\n4.  **Klasse `Main` (of `Hoofdklasse`):**\n    * Pas de `main` methode uit H11.1 aan.\n    * Maak `Pedalo` objecten aan.\n    * Maak `Reservatie` objecten aan voor pedalo's (met gewone en gouden leden).\n    * Bereken en druk de prijs af voor pedalo-reservaties.\n    * Maak een lijst van verschillende `Reservatie` objecten (met zeilboten, motorboten, pedalo's).\n    * Sorteer deze lijst op basis van de reservatieprijs en druk de gesorteerde lijst af.",
    "starter_code": "```java\n// Aannames: Klassen Lid, GewoonLid, GoudenLid, Boot, Zeilboot, Motorboot, Reservatie, Main uit H11.1 zijn beschikbaar.\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.ArrayList;\n\n// Optie 1: Pedalo extends Boot (als Boot flexibel genoeg is)\n/*\nclass Pedalo extends Boot {\n    private static double prijsPerUurStandaard = 25.0; // 6.25 * 4\n\n    public Pedalo(String naam) {\n        // Roep super constructor aan. Radar is altijd false.\n        // PrijsPerUur kan hier de standaardwaarde krijgen of via parameter.\n        super(naam, prijsPerUurStandaard, false); \n    }\n\n    // Override prijsberekening: geen extra toeslagen\n    @Override\n    public double getTotalePrijsPerUur() {\n        // Retourneert enkel de basisprijs (eventueel aanpasbaar gemaakt)\n        return this.prijsPerUur; // prijsPerUur is protected in Boot\n    }\n\n    // Methode om prijs aan te passen (indien nodig)\n    public void setPrijsPerUur(double nieuwePrijs) {\n        this.prijsPerUur = nieuwePrijs;\n    }\n}\n*/\n\n// Optie 2: Interface Verhuurbaar (flexibeler)\ninterface Verhuurbaar {\n    String getNaam();\n    double getTotalePrijsPerUur();\n}\n\n// Boot implementeert dan Verhuurbaar\n/*\nabstract class Boot implements Verhuurbaar {\n    // ... bestaande code ...\n    @Override\n    public String getNaam() { return naam; }\n    // getTotalePrijsPerUur() is al abstract of geïmplementeerd\n}\n*/\n\n// Pedalo implementeert Verhuurbaar\nclass Pedalo implements Verhuurbaar {\n    private String naam;\n    private double prijsPerUur = 25.0; // Standaardprijs\n\n    public Pedalo(String naam) {\n        this.naam = naam;\n    }\n\n    @Override\n    public String getNaam() { return naam; }\n\n    @Override\n    public double getTotalePrijsPerUur() {\n        return prijsPerUur;\n    }\n\n    public void setPrijsPerUur(double prijsPerUur) {\n        this.prijsPerUur = prijsPerUur;\n    }\n}\n\n\n// Aanpassing aan Reservatie klasse\nclass Reservatie implements Comparable<Reservatie> {\n    private Lid lid;\n    // private Boot boot; // Wordt nu Verhuurbaar als interface gebruikt wordt\n    private Verhuurbaar item; // Gebruik interface type\n    private double aantalUren;\n\n    // Constructor aanpassen aan Verhuurbaar item\n    public Reservatie(Lid lid, Verhuurbaar item, double aantalUren) {\n        this.lid = lid;\n        this.item = item;\n        this.aantalUren = aantalUren;\n    }\n\n    // Getter/Setter aantalUren\n    public double getAantalUren() { return aantalUren; }\n    public void setAantalUren(double aantalUren) { this.aantalUren = aantalUren; }\n    public Verhuurbaar getItem() { return item; }\n    public Lid getLid() { return lid; }\n\n    public double berekenPrijs() {\n        double basisPrijsPerUur = item.getTotalePrijsPerUur();\n        double totalePrijs = basisPrijsPerUur * aantalUren;\n        double korting = lid.getKortingPercentage();\n        double eindPrijs = totalePrijs * (1 - korting);\n        return eindPrijs;\n    }\n\n    // Implementatie Comparable interface\n    @Override\n    public int compareTo(Reservatie other) {\n        // Sorteer op berekende prijs (oplopend)\n        return Double.compare(this.berekenPrijs(), other.berekenPrijs());\n    }\n\n    @Override\n    public String toString() {\n        // Geeft een nette beschrijving van de reservatie\n        return \"Reservatie [Lid=\" + lid.getNaam() + \", Item=\" + item.getNaam() + \n               \", Uren=\" + aantalUren + \", Prijs=\" + String.format(\"%.2f\", berekenPrijs()) + \"]\";\n    }\n}\n\n// Aanpassing aan Main klasse\n/*\npublic class Main {\n    public static void main(String[] args) {\n        // ... maak leden (GewoonLid, GoudenLid) ...\n        // ... maak boten (Zeilboot, Motorboot) ...\n        \n        // Maak Pedalo objecten\n        Pedalo pedalo1 = new Pedalo(\"Zwaan\");\n        Pedalo pedalo2 = new Pedalo(\"Dolfijn\");\n        pedalo2.setPrijsPerUur(30.0); // Test aanpasbare prijs\n\n        // Maak een lijst van reservaties\n        List<Reservatie> reservaties = new ArrayList<>();\n        reservaties.add(new Reservatie(goudenLid, zeilbootMetAlles, 2.0));\n        reservaties.add(new Reservatie(gewoonLid, motorbootBasis, 3.0));\n        reservaties.add(new Reservatie(goudenLid, pedalo1, 1.0)); // 1 uur\n        reservaties.add(new Reservatie(gewoonLid, pedalo2, 0.5)); // Half uur\n\n        // Print ongesorteerd (optioneel)\n        System.out.println(\"Ongesorteerde Reservaties:\");\n        for(Reservatie r : reservaties) { System.out.println(r); }\n\n        // Sorteer de reservaties op prijs\n        Collections.sort(reservaties);\n\n        // Print gesorteerd\n        System.out.println(\"\\nGesorteerde Reservaties (op prijs):\");\n        for(Reservatie r : reservaties) { System.out.println(r); }\n    }\n}\n*/\n```",
    "hints": [
      "Kies de beste manier om `Pedalo` te integreren: subclass van `Boot` of via een interface `Verhuurbaar`.",
      "Als je een interface gebruikt, vergeet dan niet `implements Verhuurbaar` toe te voegen aan `Boot` (en eventueel subclasses) en `Pedalo`.",
      "Pas de `Reservatie` klasse aan om met het gekozen type (`Boot` of `Verhuurbaar`) te werken.",
      "Implementeer `Comparable<Reservatie>` in de `Reservatie` klasse.",
      "Gebruik `Double.compare(double d1, double d2)` in de `compareTo` methode voor een robuuste vergelijking van prijzen.",
      "Gebruik `Collections.sort(lijstVanReservaties)` om de lijst te sorteren."
    ],
    "solution": null,
    "testing_info": "Test in `Main` het aanmaken en reserveren van `Pedalo`'s. Verifieer de prijsberekening (€25/uur basis, geen toeslagen, wel lidkorting). Maak een gemengde lijst van reservaties en roep `Collections.sort()` aan. Controleer of de lijst correct gesorteerd is op de berekende prijs.",
    "required_files": ["Lid.java", "GewoonLid.java", "GoudenLid.java", "Boot.java", "Zeilboot.java", "Motorboot.java", "Reservatie.java", "Main.java"] // Assuming these exist from H11.1
  },
  // Entry for H12.3i
  "H12.3i": {
    "id": "H12.3i",
    "title": "Tienkamp",
    "detailed_description": "## Oefening: Tienkamp Puntenberekening en Rangschikking\n\nOntwikkel een programma om de punten voor een tienkamp te berekenen op basis van prestaties en een rangschikking van atleten te maken.\n\n**Disciplines en Formules:**\n* 10 disciplines verdeeld in Lopen, Springen, Werpen.\n* **Lopen (T in sec):** `punten = floor(a * (b - T)^c)`\n* **Springen (M in cm):** `punten = floor(a * (M - b)^c)`\n* **Werpen (D in m):** `punten = floor(a * (D - b)^c)`\n* Parameters `a`, `b`, `c` zijn per discipline gegeven (zie tabel in PDF).\n\n**Vereisten:**\n\n1.  **Klasse(n) voor Sportdisciplines (bv. `Sport` hiërarchie):**\n    * Superklasse (bv. abstract `Sport`) met parameters `a`, `b`, `c`.\n    * Methode `int berekenPunten(double prestatie)` die de punten berekent volgens de juiste formule (afhankelijk van type sport). Prestatie moet in de juiste eenheid (sec, cm, m) worden doorgegeven.\n    * Subclasses voor elke discipline (bv. `HonderdMeter extends LoopSport`) of per categorie (`LoopSport`, `SpringSport`, `WerpSport`).\n\n2.  **Enum `Sporttak`:**\n    * Bevat alle 10 sporttakken (HORDEN, VIJFTIENHONDERD_M, etc.).\n\n3.  **Klasse `TienkampSporter` implements `Comparable<TienkampSporter>`:**\n    * Attributen: `naam` (String), `sportresultaten` (`HashMap<Sporttak, Sport>`).\n    * Constructor(String naam): Initialiseert naam en vult `sportresultaten` map met instanties van alle 10 `Sport` (sub)klassen.\n    * Methode `void addPrestatie(Sporttak tak, double prestatie)`: Slaat de prestatie op in het juiste `Sport` object in de map (hiervoor moet `Sport` een veld hebben om prestatie op te slaan).\n    * Methode `int berekenPunten()`: Berekent de totale score door `berekenPunten()` aan te roepen op elk `Sport` object in de map en de resultaten op te tellen.\n    * `compareTo(TienkampSporter other)`: Vergelijkt sporters op basis van hun totale score (`berekenPunten()`), voor sortering (hoogste score eerst).\n    * `toString()`: Geeft een overzicht van de sporter, zijn totaalscore, en de prestaties/punten per discipline (zoals in het voorbeeld output).\n\n4.  **Klasse `Competitie`:**\n    * Attribuut: `List<TienkampSporter>` sporters.\n    * Methode om sporters toe te voegen.\n    * Methode `void printStand()`: Sorteert de lijst van sporters (hoogste score eerst) en drukt de rangschikking af, inclusief details per sporter via `toString()`.\n\n5.  **Klasse `Main` (of `Hoofdklasse`):**\n    * Maak een `Competitie` object.\n    * Maak 3 `TienkampSporter` objecten aan.\n    * Voeg de prestaties van Hans Van Alphen toe aan één sporter.\n    * Voeg (iets slechtere) prestaties toe aan een tweede sporter.\n    * Voeg (iets betere) prestaties toe aan een derde sporter.\n    * Voeg de sporters toe aan de `Competitie`.\n    * Roep `competitie.printStand()` aan om de eindstand af te drukken.",
    "starter_code": "```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n// Enum Sporttak\nenum Sporttak {\n    HONDERD_M, VERSPRINGEN, KOGELSTOTEN, HOOGSPRINGEN, VIERHONDERD_M, \n    HORDEN, DISCUSWERPEN, POLSSTOKHOOGSPRINGEN, SPEERWERPEN, VIJFTIENHONDERD_M\n}\n\n// Abstracte klasse Sport\nabstract class Sport {\n    protected double a, b, c; // Parameters\n    protected double prestatie = 0.0; // Opgegeven prestatie\n\n    public Sport(double a, double b, double c) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n\n    public void setPrestatie(double prestatie) {\n        this.prestatie = prestatie;\n    }\n    \n    public double getPrestatie() { return prestatie; }\n\n    // Abstracte methode voor puntenberekening\n    public abstract int berekenPunten();\n    \n    // Hulpmethode voor afronding\n    protected int floorPoints(double points) {\n        return (int) Math.floor(points);\n    }\n}\n\n// Subklassen per categorie of per sport\nclass LoopSport extends Sport {\n    public LoopSport(double a, double b, double c) { super(a, b, c); }\n    @Override\n    public int berekenPunten() {\n        if (prestatie == 0.0 || prestatie >= b) return 0; // Check prestatie vs limiet\n        // Punten = a * (b - T)^c\n        return floorPoints(a * Math.pow(b - prestatie, c));\n    }\n}\n\nclass SpringSport extends Sport {\n     public SpringSport(double a, double b, double c) { super(a, b, c); }\n    @Override\n    public int berekenPunten() {\n        if (prestatie == 0.0 || prestatie <= b) return 0; // Check prestatie vs limiet\n        // Punten = a * (M - b)^c (M in cm)\n        return floorPoints(a * Math.pow(prestatie - b, c));\n    }\n}\n\nclass WerpSport extends Sport {\n     public WerpSport(double a, double b, double c) { super(a, b, c); }\n    @Override\n    public int berekenPunten() {\n         if (prestatie == 0.0 || prestatie <= b) return 0; // Check prestatie vs limiet\n        // Punten = a * (D - b)^c (D in meters)\n        return floorPoints(a * Math.pow(prestatie - b, c));\n    }\n}\n\n// Klasse TienkampSporter\nclass TienkampSporter implements Comparable<TienkampSporter> {\n    private String naam;\n    private Map<Sporttak, Sport> sportresultaten = new HashMap<>();\n\n    public TienkampSporter(String naam) {\n        this.naam = naam;\n        initialiseerSporten();\n    }\n\n    private void initialiseerSporten() {\n        // Voeg alle 10 sporten toe met hun parameters\n        sportresultaten.put(Sporttak.HONDERD_M, new LoopSport(25.4347, 18, 1.81));\n        sportresultaten.put(Sporttak.VERSPRINGEN, new SpringSport(0.14354, 220, 1.4));\n        sportresultaten.put(Sporttak.KOGELSTOTEN, new WerpSport(51.39, 1.5, 1.05));\n        sportresultaten.put(Sporttak.HOOGSPRINGEN, new SpringSport(0.8465, 75, 1.42));\n        sportresultaten.put(Sporttak.VIERHONDERD_M, new LoopSport(1.53775, 82, 1.81));\n        sportresultaten.put(Sporttak.HORDEN, new LoopSport(5.74352, 28.5, 1.92));\n        sportresultaten.put(Sporttak.DISCUSWERPEN, new WerpSport(12.91, 4, 1.1));\n        sportresultaten.put(Sporttak.POLSSTOKHOOGSPRINGEN, new SpringSport(0.2797, 100, 1.35));\n        sportresultaten.put(Sporttak.SPEERWERPEN, new WerpSport(10.14, 7, 1.08));\n        sportresultaten.put(Sporttak.VIJFTIENHONDERD_M, new LoopSport(0.03768, 480, 1.85));\n    }\n\n    public void addPrestatie(Sporttak tak, double prestatie) {\n        if (sportresultaten.containsKey(tak)) {\n            sportresultaten.get(tak).setPrestatie(prestatie);\n        }\n    }\n\n    public int berekenPunten() {\n        int totaal = 0;\n        for (Sport s : sportresultaten.values()) {\n            totaal += s.berekenPunten();\n        }\n        return totaal;\n    }\n\n    @Override\n    public int compareTo(TienkampSporter other) {\n        // Sorteer aflopend op totaalscore\n        return Integer.compare(other.berekenPunten(), this.berekenPunten());\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(naam).append(\" \").append(berekenPunten()).append(\"\\n\");\n        // Voeg details per sport toe (formaat nog te bepalen)\n        for (Map.Entry<Sporttak, Sport> entry : sportresultaten.entrySet()) {\n             sb.append(entry.getKey()).append(\": \")\n               .append(entry.getValue().getPrestatie()) // Voeg eenheid toe?\n               .append(\" \").append(entry.getValue().berekenPunten()).append(\" punten\\n\");\n        }\n        return sb.toString();\n    }\n}\n\n// Klasse Competitie\nclass Competitie {\n    private List<TienkampSporter> sporters = new ArrayList<>();\n\n    public void voegSporterToe(TienkampSporter sporter) {\n        sporters.add(sporter);\n    }\n\n    public void printStand() {\n        Collections.sort(sporters); // Sorteert op basis van compareTo\n        System.out.println(\"Eindstand =\");\n        for (TienkampSporter sporter : sporters) {\n            System.out.println(sporter); // Gebruikt toString()\n        }\n    }\n}\n\n// Klasse Main\npublic class Main {\n    public static void main(String[] args) {\n        Competitie competitie = new Competitie();\n\n        // Maak sporters\n        TienkampSporter vanAlphen = new TienkampSporter(\"vanAlphen\");\n        TienkampSporter slechter = new TienkampSporter(\"slechter\");\n        TienkampSporter beter = new TienkampSporter(\"beter\");\n\n        // Voeg prestaties toe (voorbeeld voor Van Alphen)\n        vanAlphen.addPrestatie(Sporttak.HONDERD_M, 11.09); // sec\n        vanAlphen.addPrestatie(Sporttak.VERSPRINGEN, 727.0); // cm\n        vanAlphen.addPrestatie(Sporttak.KOGELSTOTEN, 15.29); // m\n        vanAlphen.addPrestatie(Sporttak.HOOGSPRINGEN, 201.0); // cm\n        vanAlphen.addPrestatie(Sporttak.VIERHONDERD_M, 49.06); // sec\n        vanAlphen.addPrestatie(Sporttak.HORDEN, 14.96); // sec\n        vanAlphen.addPrestatie(Sporttak.DISCUSWERPEN, 48.92); // m\n        vanAlphen.addPrestatie(Sporttak.POLSSTOKHOOGSPRINGEN, 472.0); // cm\n        vanAlphen.addPrestatie(Sporttak.SPEERWERPEN, 65.76); // m\n        vanAlphen.addPrestatie(Sporttak.VIJFTIENHONDERD_M, 270.22); // sec (4*60 + 30.22)\n\n        // TODO: Voeg prestaties toe voor 'slechter' en 'beter'\n\n        // Voeg sporters toe aan competitie\n        competitie.voegSporterToe(vanAlphen);\n        competitie.voegSporterToe(slechter);\n        competitie.voegSporterToe(beter);\n\n        // Print de stand\n        competitie.printStand();\n    }\n}\n```",
    "hints": [
      "Gebruik een abstracte klasse `Sport` en concrete subclasses per categorie of discipline.",
      "Sla de parameters a, b, c op in de `Sport` (sub)klassen.",
      "Implementeer de puntenformules correct, let op de eenheden (sec, cm, m).",
      "Gebruik `Math.floor()` voor afronding en `Math.pow()` voor machten.",
      "Gebruik een `HashMap<Sporttak, Sport>` in `TienkampSporter`.",
      "Laat `TienkampSporter` de `Comparable` interface implementeren om sortering mogelijk te maken.",
      "Gebruik `Collections.sort()` in `Competitie` om de sporters te sorteren."
    ],
    "solution": null,
    "testing_info": "Voer de `main` methode uit. Vul de prestaties voor de drie sporters in (Hans Van Alphen, een slechtere, een betere). Controleer of de `printStand()` methode de sporters correct sorteert op basis van hun totale score en of de output overeenkomt met het voorbeeldformaat.",
    "required_files": []
  },
  // Entry for H14.1
  "H14.1": {
    "id": "H14.1",
    "title": "Watersportclub_MetExceptions",
    "detailed_description": "## Oefening: Watersportclub 'waterdicht' maken met Exceptions\n\nBreid de watersportclub-oefening (H12.2 met Pedalo's) uit met exception handling om ongeldige (negatieve) prijzen te voorkomen.\n\n**Vereisten:**\n\n1.  **Custom Exception `InvalidPriceException`:**\n    * Maak een nieuwe *unchecked* exception klasse `InvalidPriceException` (extends `RuntimeException`).\n    * Voorzie een constructor die een error message (String) accepteert.\n\n2.  **Prijsvalidatie in Constructors:**\n    * Pas de constructors van `Zeilboot`, `Motorboot`, en `Pedalo` (of de relevante constructor in de `Boot` superklasse/interface implementatie) aan.\n    * Voeg aan het begin van de constructor een controle toe: als de opgegeven `prijsPerUur` (of basisprijs) negatief is, `throw new InvalidPriceException(\"Prijs mag niet negatief zijn.\")`.\n    * Dit voorkomt dat een object met een ongeldige prijs wordt aangemaakt.\n\n3.  **Testen en Afhandelen in `Main`:**\n    * Pas de `main` methode aan (of gebruik het voorbeeld uit de PDF).\n    * Probeer objecten (Motorboot, Zeilboot, Pedalo) aan te maken met negatieve prijzen.\n    * Observeer dat het programma crasht met een `InvalidPriceException`.\n    * Wijzig de `main` methode: plaats de code die objecten aanmaakt binnen `try-catch` blokken.\n    * Vang specifiek de `InvalidPriceException` op.\n    * In het `catch` blok, druk een duidelijke foutmelding af (bv. `e.getMessage()`) maar laat het programma verdergaan met de volgende stappen (bv. het aanmaken van andere, geldige objecten).",
    "starter_code": "```java\n// Aannames: Klassen Lid, GewoonLid, GoudenLid, Boot/Verhuurbaar, Zeilboot, Motorboot, Pedalo, Reservatie, Main uit H12.2 zijn beschikbaar.\n\n// 1. Custom Exception Klasse\nclass InvalidPriceException extends RuntimeException {\n    public InvalidPriceException(String message) {\n        super(message);\n    }\n}\n\n// 2. Aanpassing aan Constructors (voorbeeld voor Boot superklasse)\n/*\nabstract class Boot implements Verhuurbaar {\n    // ... bestaande attributen ...\n\n    public Boot(String naam, double prijsPerUur, boolean heeftRadar) {\n        if (prijsPerUur < 0) {\n            throw new InvalidPriceException(\"Prijs voor boot '\" + naam + \"' mag niet negatief zijn: \" + prijsPerUur);\n        }\n        this.naam = naam;\n        this.prijsPerUur = prijsPerUur;\n        this.heeftRadar = heeftRadar;\n    }\n    // ... rest van de klasse ...\n}\n\n// Aanpassing voor Pedalo (indien aparte klasse)\nclass Pedalo implements Verhuurbaar {\n     // ... bestaande attributen ...\n     public Pedalo(String naam, double prijsPerUur) { // Aangepaste constructor indien prijs initieel gezet wordt\n         if (prijsPerUur < 0) {\n             throw new InvalidPriceException(\"Prijs voor pedalo '\" + naam + \"' mag niet negatief zijn: \" + prijsPerUur);\n         }\n         this.naam = naam;\n         this.prijsPerUur = prijsPerUur;\n     }\n     // ... rest van de klasse ...\n}\n*/\n\n// 3. Aanpassing aan Main klasse\n/*\npublic class Main {\n    public static void main(String[] args) {\n        Lid hendrik = new GoudenLid(\"Hendrik\", \"0472/333333\", 5);\n        Lid philippe = new GewoonLid(\"Philippe\", \"0495/444444\"); // Aangepast type\n\n        Boot kanNiet = null;\n        try {\n            // Poging om boot met negatieve prijs te maken\n            kanNiet = new Motorboot(\"KanNiet\", -23, true, true);\n            System.out.println(\"Prijs per uur KanNiet: \" + kanNiet.getTotalePrijsPerUur()); // Wordt niet bereikt\n        } catch (InvalidPriceException e) {\n            System.err.println(\"Fout bij aanmaken boot 'KanNiet': \" + e.getMessage());\n        }\n\n        // Verdere code wordt nu wel uitgevoerd\n        Boot marieLouise = null;\n        try {\n             marieLouise = new Zeilboot(\"Marie-Louise\", 30, false, true);\n             System.out.println(\"Prijs per uur Marie-Louise: \" + marieLouise.getTotalePrijsPerUur());\n             Reservatie marieLouiseHendrik = new Reservatie(hendrik, marieLouise, 10);\n             System.out.println(\"Hendrik moet \" + String.format(\"%.2f\", marieLouiseHendrik.berekenPrijs()) + \"€ betalen\");\n        } catch (InvalidPriceException e) {\n             System.err.println(\"Onverwachte fout bij aanmaken boot 'Marie-Louise': \" + e.getMessage());\n        }\n        \n        Verhuurbaar pedaloNegatief = null; // Gebruik interface type\n         try {\n             pedaloNegatief = new Pedalo(\"PedaloFout\"); // Stel dat Pedalo constructor geen prijs neemt\n             ((Pedalo) pedaloNegatief).setPrijsPerUur(-23); // Fout bij setter?\n             // Of als constructor prijs neemt:\n             // pedaloNegatief = new Pedalo(\"PedaloFout\", -23.0);\n             System.out.println(\"Prijs per uur PedaloFout: \" + pedaloNegatief.getTotalePrijsPerUur());\n         } catch (InvalidPriceException e) { // Of waar de check ook zit\n             System.err.println(\"Fout bij aanmaken/instellen pedalo 'PedaloFout': \" + e.getMessage());\n         }\n\n        System.out.println(\"\\nProgramma gaat verder...\");\n    }\n}\n*/\n```",
    "hints": [
      "Maak `InvalidPriceException` een subclass van `RuntimeException` zodat het een unchecked exception is.",
      "Voeg de `if (prijs < 0) { throw ... }` controle toe *voordat* de attributen worden geïnitialiseerd in de constructors (of setters indien prijs daar wordt ingesteld).",
      "Gebruik `try { ... } catch (InvalidPriceException e) { ... }` in de `main` methode om de code die de exception kan gooien te omvatten.",
      "In de `catch` block, print de error message (`e.getMessage()`) of de volledige stack trace (`e.printStackTrace()`) voor debugging."
    ],
    "solution": null,
    "testing_info": "Voer de aangepaste `Main` methode uit. Verifieer dat bij pogingen om objecten met negatieve prijzen aan te maken, de `InvalidPriceException` wordt gevangen, een foutmelding wordt getoond, maar het programma niet stopt en verdergaat met het verwerken van geldige objecten.",
    "required_files": ["Lid.java", "GewoonLid.java", "GoudenLid.java", "Boot.java", "Zeilboot.java", "Motorboot.java", "Pedalo.java", "Reservatie.java", "Main.java"] // Assuming these exist from H12.2
  },
  // Entry for H14.2
  "H14.2": {
    "id": "H14.2",
    "title": "Exceptions",
    "detailed_description": "## Oefening: Exception Propagation en Wrapping\n\nBestudeer hoe exceptions door de call stack propageren en hoe ze kunnen worden opgevangen en omgezet (wrapping).\n\n**Scenario:**\nEen klasse `Worker` heeft een keten van methode-aanroepen: `start()` -> `methodeA()` -> `methodeB()` -> `methodeC()` -> `methodeD()` -> `methodeE()`.\n\n**Stappen:**\n\n1.  **Basis Implementatie:** Implementeer de `Worker` klasse waarbij `methodeE()` een succesbericht print. Maak een `Main` klasse die `worker.start()` aanroept. Test dit.\n2.  **Introduceer Fout:** Wijzig `methodeE()` zodat het `throw new UnsupportedOperationException();` uitvoert. Run `Main` opnieuw en observeer de stack trace op de console.\n3.  **Custom Exceptions:** Maak de volgende exception klassen aan:\n    * `ExceptionD extends Exception` (Checked)\n    * `ExceptionB extends RuntimeException` (Unchecked)\n    * `WorkerException extends Exception` (Checked)\n4.  **Exception Handling in `Worker`:**\n    * `methodeE()`: Gooit `UnsupportedOperationException`.\n    * `methodeD()`: Vangt `UnsupportedOperationException` op. Gooit een *nieuwe* `ExceptionD` met de originele exception als oorzaak (`throw new ExceptionD(\"Fout in E\", e);`). Voeg `throws ExceptionD` toe aan de signatuur van `methodeD()`.\n    * `methodeC()`: Handelt geen exceptions af, maar moet `ExceptionD` doorgeven. Voeg `throws ExceptionD` toe aan de signatuur.\n    * `methodeB()`: Vangt `ExceptionD` op. Gooit een *nieuwe* `ExceptionB` met `ExceptionD` als oorzaak (`throw new ExceptionB(\"Fout vanuit D\", e);`). Voeg `throws ExceptionD` toe aan de signatuur om `ExceptionD` te kunnen vangen (of vang `Exception`).\n    * `methodeA()`: Handelt geen exceptions af. `ExceptionB` is unchecked en propageert automatisch.\n    * `start()`: Vangt *alle* mogelijke exceptions op (`catch (Exception e)`). Gooit een *nieuwe* `WorkerException` met een algemene boodschap en de gevangen exception als oorzaak (`throw new WorkerException(\"Worker gefaald\", e);`). Voeg `throws WorkerException` toe aan de signatuur.\n5.  **Afhandeling in `Main`:**\n    * Roep `worker.start()` aan binnen een `try-catch` blok.\n    * Vang de `WorkerException` op.\n    * Print de message van de `WorkerException` (`e.getMessage()`) en eventueel de oorzaak (`e.getCause()`).",
    "starter_code": "```java\n// Package: be.vives.ti.doorgeven.exceptions\nclass ExceptionD extends Exception {\n    public ExceptionD(String message, Throwable cause) {\n        super(message, cause);\n    }\n}\n\nclass ExceptionB extends RuntimeException {\n    public ExceptionB(String message, Throwable cause) {\n        super(message, cause);\n    }\n}\n\nclass WorkerException extends Exception {\n    public WorkerException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}\n\n// Package: be.vives.ti.doorgeven\n// Importeer de exceptions\nimport be.vives.ti.doorgeven.exceptions.*;\n\nclass Worker {\n\n    public void start() throws WorkerException { // Moet WorkerException declareren\n        try {\n            methodeA();\n        } catch (Exception e) { // Vang alles op (incl. ExceptionB)\n            throw new WorkerException(\"Worker gefaald\", e);\n        }\n    }\n\n    private void methodeA() throws ExceptionD { // Moet ExceptionD doorgeven (via B en C)\n        System.out.println(\"Methode A start\");\n        methodeB(); // Kan ExceptionB gooien (unchecked), of ExceptionD (checked)\n        System.out.println(\"Methode A eindigt\");\n    }\n\n    private void methodeB() throws ExceptionD { // Moet ExceptionD doorgeven (van C)\n        System.out.println(\"Methode B start\");\n        try {\n            methodeC();\n        } catch (ExceptionD e) { // Vang ExceptionD\n            // Gooi unchecked ExceptionB, wrapping ExceptionD\n            throw new ExceptionB(\"Fout vanuit D\", e);\n        }\n        System.out.println(\"Methode B eindigt\");\n    }\n\n    private void methodeC() throws ExceptionD { // Moet ExceptionD doorgeven\n        System.out.println(\"Methode C start\");\n        methodeD(); // Gooit ExceptionD\n        System.out.println(\"Methode C eindigt\");\n    }\n\n    private void methodeD() throws ExceptionD { // Declareert ExceptionD\n        System.out.println(\"Methode D start\");\n        try {\n            methodeE();\n        } catch (UnsupportedOperationException e) { // Vang specifieke unchecked exception\n            // Gooi checked ExceptionD, wrapping de oorzaak\n            throw new ExceptionD(\"Fout in E\", e);\n        }\n        System.out.println(\"Methode D eindigt\");\n    }\n\n    private void methodeE() {\n        System.out.println(\"Methode E start\");\n        // Origineel: System.out.println(\"Methode E werd succesvol uitgevoerd\");\n        throw new UnsupportedOperationException(\"Operatie niet ondersteund in E!\");\n    }\n}\n\n// Klasse Main (in bv. be.vives.ti.doorgeven)\nimport be.vives.ti.doorgeven.exceptions.WorkerException;\n\npublic class Main {\n    public static void main(String[] args) {\n        Worker worker = new Worker();\n        try {\n            worker.start();\n            System.out.println(\"Worker succesvol uitgevoerd.\"); // Wordt niet bereikt\n        } catch (WorkerException e) {\n            System.err.println(\"Fout opgetreden in Worker: \" + e.getMessage());\n            System.err.println(\"Oorzaak: \" + e.getCause()); // Toon de onderliggende exception\n            // e.printStackTrace(); // Voor volledige stack trace\n        }\n        System.out.println(\"Programma normaal beëindigd.\");\n    }\n}\n```",
    "hints": [
      "Checked exceptions (subclasses van `Exception` maar niet `RuntimeException`) moeten worden afgehandeld (try-catch) of doorgegeven (throws clause).",
      "Unchecked exceptions (subclasses van `RuntimeException`) hoeven niet verplicht afgehandeld of gedeclareerd te worden, maar kunnen wel.",
      "Gebruik de constructor `Exception(String message, Throwable cause)` om de originele exception mee te geven bij het 'wrappen'.",
      "Volg de flow van de exception door de method calls en de `throws`/`catch` blokken."
    ],
    "solution": null,
    "testing_info": "Voer de `main` methode uit. Controleer of de `WorkerException` correct wordt opgevangen in `main`. Bekijk de output van `e.getMessage()` en `e.getCause()` om te zien hoe de exceptions zijn doorgegeven en verpakt.",
    "required_files": []
  }
// New entry for HO.1
  "HO.1": {
    "id": "HO.1",
    "title": "Kinderopvang",
    "detailed_description": "## Oefening: Kinderopvang Simulatie\n\nModelleer een kinderopvangsysteem met twee types: `Onthaalmoeder` en `Creche`, met verschillende regels en functionaliteiten. Focus op overerving, exceptions, datums en testen.\n\n**Algemene Informatie:**\n* `Kind`: `naam` (String), `geboortedatum` (`java.time.LocalDate`). Leeftijd moet berekenbaar zijn.\n* `Verzorger`: `naam` (String), `geboortedatum` (`LocalDate`), `startdatum` (`LocalDate`). Leeftijd en diensttijd moeten berekenbaar zijn.\n\n**Type Opvang:**\n\n1.  **`Onthaalmoeder`:**\n    * Regels: Max 8 kinderen, min 1 verzorger. Geen leeftijdsbeperking voor kinderen.\n    * Opstarten: Constructor controleert of minstens 1 verzorger is meegegeven, anders `throw OngeldigAantalInOpvangException`.\n    * `inschrijvenKind(Kind kind)`: Controleert of max 8 kinderen niet overschreden wordt, anders `throw OngeldigAantalInOpvangException`.\n    * Methodes: `getLijstKinderenAsString()`, `getLijstVerzorgersAsString()`.\n\n2.  **`Creche`:**\n    * Regels: Max 100 kinderen. Min 2 verzorgers. Vanaf 15 kinderen: 1 verzorger per 14 kinderen (bv. 1-14 kinderen -> 2 verzorgers; 15-28 -> 2 verzorgers; 29-42 -> 3 verzorgers, etc.). Kinderen max 3 jaar oud.\n    * Opstarten: Constructor controleert of minstens 2 verzorgers zijn meegegeven, anders `throw OngeldigAantalInOpvangException`.\n    * `inschrijvenKind(Kind kind)`:\n        * Controleert of kind <= 3 jaar oud is, anders `throw OngeldigLeeftijdKindException`.\n        * Controleert of max 100 kinderen niet overschreden wordt, anders `throw OngeldigAantalInOpvangException`.\n        * Controleert of er voldoende verzorgers zijn *na* toevoeging van dit kind volgens de 1/14 regel (met min 2), anders `throw OngeldigAantalInOpvangException`.\n    * Methodes: `getLijstKinderenAsString()`, `getLijstVerzorgersAsString()`.\n\n**Exceptions:**\n* Definieer custom *unchecked* exceptions: `OngeldigAantalInOpvangException`, `OngeldigLeeftijdKindException`.\n\n**Hoofdprogramma (`Main`):**\n* Maak een `Creche` aan met 2 verzorgers.\n* Implementeer een lus die gebruikersinput vraagt (naam, geboortejaar/-maand/-dag) om kinderen toe te voegen aan de crèche. Blijf vragen tot de gebruiker stopt.\n* Vang alle mogelijke exceptions (ook `DateTimeParseException` voor ongeldige datuminput) netjes op en toon een duidelijke foutmelding aan de gebruiker.\n* Implementeer een gelijkaardige lus voor een `Onthaalmoeder`.\n\n**JUnit Testen:**\n* Schrijf testen voor: `Creche` (constructor, inschrijvenKind), `Onthaalmoeder` (constructor, inschrijvenKind), `Kind` (leeftijd berekenen).",
    "starter_code": "```java\nimport java.time.LocalDate;\nimport java.time.Period;\nimport java.time.format.DateTimeParseException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\n// Custom Exceptions\nclass OngeldigAantalInOpvangException extends RuntimeException {\n    public OngeldigAantalInOpvangException(String message) { super(message); }\n}\nclass OngeldigLeeftijdKindException extends RuntimeException {\n    public OngeldigLeeftijdKindException(String message) { super(message); }\n}\n\n// Klasse Kind\nclass Kind {\n    private String naam;\n    private LocalDate geboortedatum;\n\n    public Kind(String naam, LocalDate geboortedatum) { /*...*/ }\n    public String getNaam() { /*...*/ return null; }\n    public LocalDate getGeboortedatum() { /*...*/ return null; }\n    public int getLeeftijd() {\n        // TODO: Bereken leeftijd met Period.between()\n        return 0; \n    }\n    @Override public String toString() { /*...*/ return \"\"; }\n}\n\n// Klasse Verzorger\nclass Verzorger {\n    private String naam;\n    private LocalDate geboortedatum;\n    private LocalDate startdatum;\n\n    public Verzorger(String naam, LocalDate geboortedatum, LocalDate startdatum) { /*...*/ }\n    // TODO: Getters\n    // TODO: getLeeftijd()\n    // TODO: getDiensttijd() ? (niet expliciet gevraagd)\n    @Override public String toString() { /*...*/ return \"\"; }\n}\n\n// Abstracte superklasse Kinderopvang (optioneel)\nabstract class Kinderopvang {\n    protected List<Kind> kinderen = new ArrayList<>();\n    protected List<Verzorger> verzorgers = new ArrayList<>();\n    \n    // Gemeenschappelijke methodes?\n    public abstract void inschrijvenKind(Kind kind);\n    public String getLijstKinderenAsString() { /*...*/ return \"\"; }\n    public String getLijstVerzorgersAsString() { /*...*/ return \"\"; }\n}\n\n// Klasse Onthaalmoeder\nclass Onthaalmoeder extends Kinderopvang { // Of implementeer direct\n    private static final int MAX_KINDEREN = 8;\n\n    public Onthaalmoeder(List<Verzorger> startVerzorgers) {\n        // TODO: Check min 1 verzorger, anders throw OngeldigAantalInOpvangException\n        // TODO: Voeg startVerzorgers toe\n    }\n\n    @Override\n    public void inschrijvenKind(Kind kind) {\n        // TODO: Check if kinderen.size() < MAX_KINDEREN, anders throw OngeldigAantalInOpvangException\n        // TODO: Voeg kind toe\n    }\n}\n\n// Klasse Creche\nclass Creche extends Kinderopvang { // Of implementeer direct\n    private static final int MAX_KINDEREN = 100;\n    private static final int KINDEREN_PER_VERZORGER = 14;\n    private static final int MIN_VERZORGERS = 2;\n\n    public Creche(List<Verzorger> startVerzorgers) {\n         // TODO: Check min 2 verzorgers, anders throw OngeldigAantalInOpvangException\n         // TODO: Voeg startVerzorgers toe\n    }\n\n    @Override\n    public void inschrijvenKind(Kind kind) {\n        // TODO: Check leeftijd kind (<= 3), anders throw OngeldigLeeftijdKindException\n        // TODO: Check max capaciteit (100), anders throw OngeldigAantalInOpvangException\n        // TODO: Check vereiste aantal verzorgers voor (kinderen.size() + 1), anders throw OngeldigAantalInOpvangException\n        // TODO: Voeg kind toe\n    }\n\n    private int berekenMinVereisteVerzorgers(int aantalKinderen) {\n        if (aantalKinderen <= KINDEREN_PER_VERZORGER) return MIN_VERZORGERS;\n        // Berekening: 1 voor eerste 14, +1 per volgende 14 (of deel ervan)\n        // int groepenVan14 = (int) Math.ceil((double)(aantalKinderen - KINDEREN_PER_VERZORGER) / KINDEREN_PER_VERZORGER);\n        // return MIN_VERZORGERS + groepenVan14; // Check logica!\n        // Alternatief: (aantalKinderen + KINDEREN_PER_VERZORGER - 1) / KINDEREN_PER_VERZORGER + 1 ? Nee... \n        // Simpeler: als <= 14 -> 2; als > 14 -> ceil(aantal / 14) + 1 ? Nee... \n        // Correct: als <= 28 -> 2; als > 28 -> ceil(aantal/14) ? Nee... \n        // Correct: als <= 14 -> 2; als > 14 -> 1 + ceil( (aantal-1)/14 ) ? Check pdf: <14 -> 2; >=14 -> 1 per 14. Dus 1-14 -> 2; 15-28 -> 2; 29-42 -> 3; etc.\n        if (aantalKinderen <= 28) return MIN_VERZORGERS;\n        return (int) Math.ceil((double) aantalKinderen / KINDEREN_PER_VERZORGER); // Klopt dit? 29/14=2.07->3; 42/14=3; 43/14=3.07->4. Lijkt te kloppen vanaf 29.\n    }\n}\n\n// Klasse Main\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        // TODO: Maak Creche/Onthaalmoeder aan (met try-catch voor constructor)\n        // TODO: Implementeer input lus voor kinderen (met try-catch voor exceptions)\n        //       Gebruik LocalDate.of(jaar, maand, dag) en vang DateTimeParseException\n        scanner.close();\n    }\n}\n```",
    "hints": [
      "Gebruik `java.time.LocalDate` voor datums.",
      "Gebruik `Period.between(geboortedatum, LocalDate.now()).getYears()` om leeftijd te berekenen.",
      "Overweeg een abstracte klasse `Kinderopvang` voor gedeelde logica.",
      "Implementeer de regels voor het aantal verzorgers in `Creche` nauwkeurig.",
      "Maak de custom exceptions unchecked (`extends RuntimeException`).",
      "Gebruik `try-catch` blokken in `Main` om invoerfouten en validatiefouten (exceptions uit `inschrijvenKind`) op te vangen.",
      "Voor de input lus: gebruik `scanner.nextLine()` na `scanner.nextInt()` om de newline op te vangen, of lees alles als String en parse."
    ],
    "solution": null,
    "testing_info": "Schrijf JUnit testen voor de aangegeven klassen en methodes. Test specifiek de grenzen van het aantal kinderen, de leeftijdslimiet in de crèche, en de berekening van het vereiste aantal verzorgers. Test ook de exception handling in `Main` door ongeldige data in te voeren.",
    "required_files": []
  },
  // New entry for HO.2
  "HO.2": {
    "id": "HO.2",
    "title": "Rekening",
    "detailed_description": "## Oefening: Zicht- en Spaarrekeningen\n\nModelleer zicht- en spaarrekeningen met verschillende regels voor saldo en renteberekening. Implementeer exception handling en sortering.\n\n**Vereisten:**\n\n1.  **Abstracte Superklasse `Rekening` implements `Comparable<Rekening>`:**\n    * Attributen: `rekeningnummer` (String, final?), `naamKlant` (String), `saldo` (double, initieel 0).\n    * Constructor (voor rekeningnummer, naamKlant).\n    * `double getSaldo()`.\n    * `void stortGeld(double bedrag) throws NegatiefBedragException`: Stort bedrag. Gooit *checked* `NegatiefBedragException` als bedrag < 0.\n    * `void neemGeldOp(double bedrag) throws NegatiefBedragException`: Neemt bedrag op. Gooit *checked* `NegatiefBedragException` als bedrag < 0. (Basis implementatie, subclasses overschrijven indien nodig).\n    * `compareTo(Rekening other)`: Vergelijkt op `rekeningnummer`.\n    * `toString()`.\n\n2.  **Subklasse `Zichtrekening` extends `Rekening`:**\n    * Saldo mag negatief worden. De `neemGeldOp` methode van de superklasse hoeft mogelijk niet overschreven te worden qua saldo-check.\n    * Constructor.\n    * `toString()`.\n\n3.  **Subklasse `Spaarrekening` extends `Rekening`:**\n    * Saldo mag niet negatief worden.\n    * Overschrijft `neemGeldOp(double bedrag) throws NegatiefBedragException`: Roept eerst `super.neemGeldOp()` aan (voor negatief bedrag check). Controleert daarna of `saldo >= bedrag`. Indien nee, gooi *unchecked* `SaldoOntoereikendException`.\n    * Methode `void berekenRente(double renteVoet)`: Berekent rente (`saldo * renteVoet`) en telt deze op bij het saldo.\n    * Constructor.\n    * `toString()`.\n\n4.  **Custom Exceptions:**\n    * `NegatiefBedragException extends Exception`: Checked exception voor ongeldige storting/opname. Moet het ongeldige bedrag bevatten (bv. via attribuut en getter).\n    * `SaldoOntoereikendException extends RuntimeException`: Unchecked exception voor spaarrekening opname. Moet het huidige saldo en het gevraagde bedrag bevatten.\n\n5.  **Hoofdprogramma (`Main`):**\n    * Maak een `List<Rekening>`.\n    * Creëer `Zichtrekening` en `Spaarrekening` objecten en voeg toe aan de lijst.\n    * Voer stortingen en opnames uit (test geldige, negatieve bedragen, en ontoereikend saldo voor spaarrekening). Gebruik `try-catch` voor `NegatiefBedragException`.\n    * Druk info af na operaties.\n    * Itereer door de lijst: als een rekening `instanceof Spaarrekening`, roep `berekenRente()` aan.\n    * Druk info opnieuw af.\n    * Sorteer de lijst (`Collections.sort()`).\n    * Druk de gesorteerde lijst af.",
    "starter_code": "```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n// Custom Exceptions\nclass NegatiefBedragException extends Exception { // Checked\n    private double ongeldigBedrag;\n    public NegatiefBedragException(String message, double bedrag) {\n        super(message);\n        this.ongeldigBedrag = bedrag;\n    }\n    public double getOngeldigBedrag() { return ongeldigBedrag; }\n}\n\nclass SaldoOntoereikendException extends RuntimeException { // Unchecked\n    private double huidigSaldo;\n    private double gevraagdBedrag;\n    public SaldoOntoereikendException(String message, double saldo, double bedrag) {\n        super(message);\n        this.huidigSaldo = saldo;\n        this.gevraagdBedrag = bedrag;\n    }\n    public double getHuidigSaldo() { return huidigSaldo; }\n    public double getGevraagdBedrag() { return gevraagdBedrag; }\n}\n\n// Abstracte Superklasse Rekening\nabstract class Rekening implements Comparable<Rekening> {\n    protected final String rekeningnummer;\n    protected String naamKlant;\n    protected double saldo;\n\n    public Rekening(String rekeningnummer, String naamKlant) {\n        this.rekeningnummer = rekeningnummer;\n        this.naamKlant = naamKlant;\n        this.saldo = 0.0;\n    }\n\n    public double getSaldo() { return saldo; }\n    public String getRekeningnummer() { return rekeningnummer; }\n    public String getNaamKlant() { return naamKlant; }\n\n    public void stortGeld(double bedrag) throws NegatiefBedragException {\n        if (bedrag < 0) {\n            throw new NegatiefBedragException(\"Kan geen negatief bedrag storten\", bedrag);\n        }\n        this.saldo += bedrag;\n    }\n\n    // Basis implementatie, kan overschreven worden\n    public void neemGeldOp(double bedrag) throws NegatiefBedragException {\n         if (bedrag < 0) {\n            throw new NegatiefBedragException(\"Kan geen negatief bedrag opnemen\", bedrag);\n        }\n        // Verdere controle (bv. saldo) in subclasses\n        // this.saldo -= bedrag; // Verplaatst naar subclasses\n    }\n\n    @Override\n    public int compareTo(Rekening other) {\n        return this.rekeningnummer.compareTo(other.rekeningnummer);\n    }\n\n    @Override\n    public abstract String toString();\n}\n\n// Subklasse Zichtrekening\nclass Zichtrekening extends Rekening {\n    public Zichtrekening(String rekeningnummer, String naamKlant) {\n        super(rekeningnummer, naamKlant);\n    }\n\n    @Override\n    public void neemGeldOp(double bedrag) throws NegatiefBedragException {\n        super.neemGeldOp(bedrag); // Checkt alleen op negatief bedrag\n        this.saldo -= bedrag; // Zichtrekening mag negatief gaan\n    }\n\n    @Override\n    public String toString() {\n        // TODO: Implementatie\n        return \"Zichtrekening [Nr=\" + rekeningnummer + \", Klant=\" + naamKlant + \", Saldo=\" + String.format(\"%.2f\", saldo) + \"]\";\n    }\n}\n\n// Subklasse Spaarrekening\nclass Spaarrekening extends Rekening {\n    public Spaarrekening(String rekeningnummer, String naamKlant) {\n        super(rekeningnummer, naamKlant);\n    }\n\n    @Override\n    public void neemGeldOp(double bedrag) throws NegatiefBedragException {\n        super.neemGeldOp(bedrag); // Checkt op negatief bedrag\n        if (this.saldo < bedrag) {\n            throw new SaldoOntoereikendException(\"Saldo ontoereikend\", this.saldo, bedrag);\n        }\n        this.saldo -= bedrag;\n    }\n\n    public void berekenRente(double renteVoet) { // bv. 0.01 voor 1%\n        if (renteVoet >= 0) { // Rente kan niet negatief zijn\n            this.saldo += this.saldo * renteVoet;\n        }\n    }\n\n    @Override\n    public String toString() {\n        // TODO: Implementatie\n         return \"Spaarrekening [Nr=\" + rekeningnummer + \", Klant=\" + naamKlant + \", Saldo=\" + String.format(\"%.2f\", saldo) + \"]\";\n    }\n}\n\n// Klasse Main\npublic class Main {\n    public static void main(String[] args) {\n        List<Rekening> rekeningen = new ArrayList<>();\n        // TODO: Maak rekeningen en voeg toe aan lijst\n        rekeningen.add(new Zichtrekening(\"BE01\", \"Jan\"));\n        rekeningen.add(new Spaarrekening(\"BE02\", \"Piet\"));\n\n        // TODO: Stortingen/opnames met try-catch voor NegatiefBedragException\n        try {\n            rekeningen.get(0).stortGeld(100);\n            rekeningen.get(1).stortGeld(500);\n            rekeningen.get(0).neemGeldOp(200); // Zicht mag negatief\n            rekeningen.get(1).neemGeldOp(100); // Spaar OK\n            // rekeningen.get(1).neemGeldOp(500); // Gooit SaldoOntoereikendException (unchecked)\n            // rekeningen.get(0).stortGeld(-50); // Gooit NegatiefBedragException (checked)\n        } catch (NegatiefBedragException e) {\n            System.err.println(\"Fout: \" + e.getMessage() + \" Bedrag: \" + e.getOngeldigBedrag());\n        } catch (SaldoOntoereikendException e) { // Optioneel, is unchecked\n             System.err.println(\"Fout: \" + e.getMessage() + \", Saldo: \" + e.getHuidigSaldo() + \", Gevraagd: \" + e.getGevraagdBedrag());\n        }\n\n        System.out.println(\"\\nRekeningen na operaties:\");\n        for (Rekening r : rekeningen) System.out.println(r);\n\n        // TODO: Bereken rente voor spaarrekeningen\n        System.out.println(\"\\nRente berekenen...\");\n        for (Rekening r : rekeningen) {\n            if (r instanceof Spaarrekening) {\n                ((Spaarrekening) r).berekenRente(0.01); // 1% rente\n            }\n        }\n\n        System.out.println(\"\\nRekeningen na rente:\");\n        for (Rekening r : rekeningen) System.out.println(r);\n\n        // TODO: Sorteer en print\n        Collections.sort(rekeningen);\n        System.out.println(\"\\nGesorteerde rekeningen:\");\n        for (Rekening r : rekeningen) System.out.println(r);\n    }\n}\n```",
    "hints": [
      "Maak `Rekening` abstract en implementeer `Comparable`.",
      "Implementeer `compareTo` op basis van `rekeningnummer`.",
      "Maak `NegatiefBedragException` checked (`extends Exception`) en `SaldoOntoereikendException` unchecked (`extends RuntimeException`).",
      "Zorg dat de exceptions nuttige informatie bevatten (bv. het ongeldige bedrag, het saldo).",
      "Handel de checked `NegatiefBedragException` af met `try-catch` waar nodig.",
      "Gebruik `instanceof` om spaarrekeningen te identificeren voor renteberekening.",
      "Gebruik `Collections.sort()` om de lijst te sorteren."
    ],
    "solution": null,
    "testing_info": "Test alle scenario's: aanmaken, storten (geldig/negatief), opnemen (geldig/negatief/saldo ontoereikend), rente berekenen, sorteren. Controleer de output en of exceptions correct worden gegooid en/of afgehandeld.",
    "required_files": []
  }
}

